<?php

/**
 * @file
 * gmod_dbsf is an API for other bioinformatic Drupal modules making use of Chado
 * it is meant to hold all the essential functions used elsewhere.
 *
 * In the settings.php this database is needed:
 * 'chado' -> read only access
 * 'chado_edit' -> read/write access
 *
 * Developed by Alexie Papanicolaou
 * @see http://insectacentral.org
 *
 * @bug The Chado database must be aliased as 'chado' in the settings.ini and the database name
 * MUST contain chado (case insensitive) (Drupal requires us to have the module name as
 * a prefix to all tables, but Chado has no prefix. Since Drupal
 * has no function to give us the alias of the active database, we have to strpos the db_name
 *
 *
 * @TODO ND Remember to refactor access control in to here from genes4all_geo
 */

/**
 * @file Developer notes
 *
 * Keep in mind that Drupal supports multiple databases but the support is buggy and often
 * causes problems.
 * The most common errors with developing new custom functions can be derived from
 * trying to run a Drupal function when connected to a secondary database (e.g. Chado).
 * Even simple functions such as t() require an active connection to Drupal in order to run.
 *
 * If in doubt, check the manual at http://api.drupal.org/api/function/
 *
 * @see gmod_dbsf_drupal_set_message()
 */

/**
 * Implements hook_menu().
 */
function gmod_dbsf_menu() {
  $items = array();
  $items['admin/settings/gmod_dbsf'] = array(
    'file' => 'includes/gmod_dbsf_admin.inc',
    'title' => 'GMOD DBSF settings',
    'page callback' => 'gmod_dbsf_admin_page',
    'access arguments' => array('Administrate GMOD DBSF'),
    'description' => 'Configure GMOD DBSF',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['feature/denied'] = array(
    'title' => 'Access denied',
    'page callback' => 'gmod_dbsf_denied_feature',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

function gmod_dbsf_denied_feature($feature=NULL){
  if (empty($feature)){
    return "No feature specified";
  }
  return t("You are not allowed to access feature %s. If you think that you should, you may ".l('contact','contact').' the administrator to provide you access.',array('%s'=>$feature));
}

/**
 * Check if the current database is a chado one
 *
 * Look for database name, not db alias in settings.ini (don't know how to get that)
 * Search is case insensitive. We use it to rewrite SQL commands, since Chado has
 * no prefixes, neither as db_prefix or due to module
 *
 * @return boolean
 * TRUE if active db is Chado, FALSE otherwise.
 */
function gmod_dbsf_is_chado() {
  global $active_db;
  $current_db = pg_dbname($active_db);
  if (stripos($current_db, 'chado') === FALSE) {
    return FALSE;
  }
  else {
    return $current_db;
  }
}

/**
 * Load any CSS used by all other modules
 */
function gmod_dbsf_init() {
  $css_file = drupal_get_path('module', 'gmod_dbsf') .'/gmod_dbsf.css';
  if (file_exists($css_file)) {
    drupal_add_css($css_file, 'module');
  }
}

/**
 * Encode a variable using base64,serialize and gzcompress
 *
 * Allows encoding of more than 2000 characters (IE6 problem)
 * @see gmod_dbsf_decode()
 *
 * @param $variable
 *   Variable to be encoded
 *
 * @return
 *   Encoded variable as a serialized string
 */
function gmod_dbsf_encode($variable) {
  if (!empty($variable)) {
    $encoded = strtr(base64_encode(addslashes(gzcompress(serialize($variable), 9))), '+/=', '-_,');
    return $encoded;
  }
}

/**
 * Decodes gmod_dbsf_encode function
 *
 * @see gmod_dbsf_encode()
 *
 * @param $encoded
 *   Variable to be decoded
 *
 * @return
 *   Decoded and unserialized variable
 */
function gmod_dbsf_decode($encoded,$check=NULL) {
  if (!empty($encoded)) {
    $string = unserialize(gzuncompress(stripslashes(base64_decode(strtr($encoded, '-_,', '+/=')))));
    if (!empty($check)){
      return check_plain($string);
    }else{
      return $string;
    }
  }
}

/**
 * Convert an array to a quoted string, suitable for SQL queries
 *
 * Essentially implode() with bells and whistles
 * @see implode()
 *
 * @param $array
 *   a list array of elements to ocnvert to a comma delimited string
 * @param $quote
 *   give TRUE to include quotes around element or pass any string
 *   to include left and right of element
 * @param $separator
 *   character to separate elements in list
 * @param $key
 *   Boolean, if true then return the keys of the $array if the value is
 *   not empty
 *
 * @return
 *  A String of comma delimited values, optionally quoted.
 */
function gmod_dbsf_array2csv($array = NULL, $quote = NULL, $separator = ',', $key = FALSE) {
  if (empty($array)) {
    return FALSE;
  }
  $quotes = '';
  if (!empty($quote)) {
    if ($quote === TRUE) {
      $quotes = "'";
    }
    else {
      $quotes = $quote;
    }
  }
  // if not an array but a string/integer
  if (is_string($array) || is_int($array)) {
    return $quotes . $array . $quotes;
  }
  //else it is an array. distinguish between using the key or the value
  $str = '';
  if (empty($key)) {
    foreach ($array as $ar) {
      $str .= $quotes . $ar . $quotes . $separator;
    }
  }
  else {
    foreach ($array as $key => $ar) {
      if (empty($ar)){continue;}
      $str .= $quotes . $key . $quotes . $separator;
    }
  }
  $str = rtrim($str, $separator);
  return $str;
}
/**
 * Pass a parameterized SQL query to an non-drupal database
 *
 * @param $db
 *   Name of database to connect to as in settings.php. If empty it connects to default
 * @param $sql
 *  SQL query to pass to the DB
 * @param $variables
 *  ?? parameterized, escaped variables to pass to the above SQL.
 *
 * @return
 *   array of results or if none expected FALSE/TRUE on failure/success
 *   respectively
 *
 * @TODO allow connection to any other database upon completion (not backwards compatible)
 */
function gmod_dbsf_query_execute($db = NULL, $sql = NULL, $variables = NULL,$reconnect=TRUE) {
  $return_array = array();
  if (empty($db)) {return;}
  global $db_url;
  if (empty($db_url[$db])) {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('The public database for %db is unavailable at this time.', array('%db' => $db)), 'error', 'FALSE');
    return FALSE;
  }
  db_set_active($db);
  $res = (empty($variables)) ? db_query($sql) : db_query($sql,$variables);
  while ($data=db_fetch_array($res)){
    $return_array[]=$data;
  }
  if (!empty($reconnect)) {
    db_set_active('default');
  }
  return $return_array;
}


/**
 * Seamlessly execute a connection to an non-drupal database
 *
 * @param $db
 *   Name of database to connect to as in settings.php. If empty it connects to default
 * @param $function
 *  Function to execute to $db. If empty, it only just connects to $db
 *  but does not re-connect to Drupal. Use with care!!!
 * @param $variables
 *  variables to pass to above function.
 *
 * @return
 *   array of results or if none expected FALSE/TRUE on failure/success
 *   respectively
 *
 * @TODO allow connection to any other database upon completion (not backwards compatible)
 */
function gmod_dbsf_db_execute($db = NULL, $function = NULL, $variables = NULL) {
  $return_array = array();
  if (!empty($db) && !empty($function)) {
    global $db_url;
    if (empty($db_url[$db])) {
      drupal_set_message(t('The public database for %db is unavailable at this time.', array('%db' => $db)), 'error', 'FALSE');
      return FALSE;
    }
    db_set_active($db);
    $argv=func_get_args();
    //first two are not used for callback
    $argn=func_num_args()-2;
    if ($argn <= 1) {
      $return_array = call_user_func($function,$variables);
    }else{
      $vars=array_slice($argv, 2,NULL,TRUE);
      $return_array = call_user_func_array($function,$vars);
    }
    db_set_active('default');
    if (!empty($return_array)) {
      return $return_array;
    }
    else {
      return 0;
    }
  }
  //simply (re)-connect. Use with care!!!
  elseif (!empty($db)) {
    global $db_url;
    if (!empty($db_url[$db])) {
      db_set_active($db);
      return 1;
    }
    else {
      db_set_active('default');
      drupal_set_message(t('The public database for %db is unavailable at this time.', array('%db' => $db)), 'error', 'FALSE');
      return FALSE;
    }
  }
  else {
    // reset to default
    db_set_active('default');
    return 1;
  }
}

/**
 * Validate and InsectaCentral accession ID.
 *
 * @param $accession
 *   ID to validate
 *
 * @return
 *   Returns correct/cleaned part of accession or FALSE on failure
 */
function gmod_dbsf_validate_ic_id($accession = NULL) {
  $accession = trim($accession);
  $accession = check_plain($accession);
  if (empty($accession)) {
    return FALSE;
  }
  preg_match("/^([A-Z]{2})(\d+)[A-Z][a-z]([A-Z][a-z]+)(\d+)/", $accession, $matches);
  if (isset($matches) && $matches[1] == "IC" && $matches[2] && $matches[3] && $matches[4]) {
    return $accession;
  }
  return FALSE;
}

/**
 * Validate that a sequence is with IUPAC DNA alphabet only
 *
 * Xs are allowed
 * @see gmod_dbsf_validate_seq_protein()
 * @todo support FASTQ
 *
 * @param $seq
 *   string of sequence to validate
 * @param $strip
 * Boolean; whether to remove any FASTA definition line from the sequence. Default to FALSE
 *
 * @return
 *   Cleaned sequence or (int) number of errors detected (or FALSE on failure)
 */
function gmod_dbsf_validate_seq_dna($seq = NULL, $strip = FALSE) {
  $seq = trim($seq);
  if (empty($seq)) {
    return FALSE;
  }
  $seq_array = explode("\r", $seq);
  $seq_new   = '';
  $error     = 0;
  foreach ($seq_array as $line) {
    $line = trim($line);
    $line = str_replace("\n", '', $line);
    if (empty($line)) {
      continue;
    }
    $defline = strpos($line, '>');
    if ($defline !== FALSE) {
      if (!empty($strip)) {
        // ignore deflines
        continue;
      }
      // '>' char does not begin at the begining. delete anything before it
      if ($defline > 0) {
        $seq_new .= "\n". substr($line, $defline) ."\n";
      }
      else {
        $seq_new .= "\n". $line ."\n";
      }
    }
    else {
      $line = str_replace(" ", '', $line);
      $line = str_replace("-", '', $line);
      $line = str_replace("*", '', $line);
      if (preg_match('/[^XatcgURMWYKBDHVSN]/i', $line)) {
        $error++;
      }
      $seq_new .= $line;
    }
  }
  if (!empty($error)) {
    return $error;
  }
  elseif (!empty($seq_new)) {
    // RNA to DNA
    $seq_new = str_ireplace('U', 'T', $seq_new);
    return $seq_new;
  }
  else {
    return FALSE;
  }
}

/**
 * Validate a protein sequence using IUPAC amino acids
 *
 * Xs are allowed
 * @see gmod_dbsf_validate_seq_dna()
 *
 * @param $seq
 *   Sequence string to validate
 * @param $strip
 * Boolean; whether to remove any FASTA definition line from the sequence. Default to FALSE
 *
 * @return
 *   Returns cleaned string or number of errors found (or FALSE on failure)
 */
function gmod_dbsf_validate_seq_protein($seq = NULL, $strip = FALSE) {
  $seq = trim($seq);
  if (empty($seq)) {
    return FALSE;
  }
  $seq_array = explode("\r", $seq);
  $seq_new   = '';
  $error     = 0;
  foreach ($seq_array as $line) {
    $line = str_ireplace("\n", '', $line);
    if (empty($line)) {
      continue;
    }
    $defline = strpos($line, '>');
    if ($defline !== FALSE) {
      if (!empty($strip)) {
        // ignore deflines
        continue;
      }
      // '>' char does not begin at the begining. delete anything before it
      if ($defline > 0) {
        $seq_new .= "\n". substr($line, $defline) ."\n";
      }
      else {
        $seq_new .= "\n". $line ."\n";
      }
    }
    else {
      $line = str_replace(" ", '', $line);
      $line = str_replace("-", '', $line);
      $line = str_replace("*", '', $line);
      if (preg_match('/[^XacdefghiklmnpqrstvwyBZJ\*]/i', $line)) {
        $error++;
      }
      $seq_new .= $line;
    }
  }
  if (!empty($error)) {
    return $error;
  }
  elseif (!empty($seq_new)) {
    return $seq_new;
  }
  else {
    return FALSE;
  }
}

/**
 * Cleans and decomposes a checkbox FAPI result array
 *
 * @param $results
 *   FAPI Checkboxes result as an associative array
 *
 * @return
 *   A list array of results
 */
function gmod_dbsf_checkboxes_results2array($results) {
  if (empty($results)) {
    return FALSE;
  }
  $array = array();
  foreach ($results as $key => $value) {
    if (empty($value)) {
      continue;
    }
    $array[] = $key;
  }
  if (!empty($array)) {
    return $array;
  }
}

/**
 *
 *
 * @see http://lsrn.org/lsrn/registry.html
 */
function gmod_dbsf_add_db($db,$dbxref_array,$db_metadata=NULL,$dbxref_descr=NULL,$dbxref_properties=NULL,$noupdate=FALSE){
  if (empty($db)||empty($dbxref_array)){return FALSE;}
  $db_descr = $db_metadata['description'];
  $db_urlprefix = $db_metadata['url_prefix'];
  $db_url = $db_metadata['url'];
  $sql_insert_db     = '';
  $sql_select_db     = '';
  $sql_check         = '';
  $sql_insert_dbxref = '';
  $sql_insert_prop ='';
  $is_a_term_id = gmod_dbsf_get_add_cv_withnames('relationship','is_a');
  $is_chado          = gmod_dbsf_is_chado();
  if ($is_chado === FALSE) {
    $sql_insert_db     = "INSERT INTO {gmod_dbsf_db} (name) VALUES ('%s')";
    $sql_update_dbdescr  = "UPDATE {gmod_dbsf_db} set description='%s' where db_id=%d";
    $sql_select_db     = "SELECT db_id FROM {gmod_dbsf_db} as db WHERE name='%s'";
    $sql_check         = "SELECT dbxref_id as id FROM {gmod_dbsf_dbxref} as dbxref WHERE accession='%s' AND db_id=%d";
    if (empty($dbxref_descr)){
      $sql_insert_dbxref = "INSERT INTO {gmod_dbsf_dbxref} (accession,db_id) VALUES ('%s',%d,%d)";
    }else{
      $sql_insert_dbxref = "INSERT INTO {gmod_dbsf_dbxref} (accession,db_id,description) VALUES ('%s',%d,%d,'%s')";
    }
  }
  else {
    // It is a Chado database; Chado has no prefixes (and Drupal has a bug when one db has a prefix)
    $sql_insert_db     = "INSERT INTO db (name) VALUES ('%s')";
    $sql_update_dbdescr  = "UPDATE {db} set description='%s' where db_id=%d";
    $sql_update_url  = "UPDATE {db} set url='%s' where db_id=%d";
    $sql_update_urlprefix  = "UPDATE {db} set urlprefix='%s' where db_id=%d";
    $sql_update_dbxrefdescr  = "UPDATE {dbxref} set description='%s' where dbxref_id=%d";
    $sql_select_db     = "SELECT db_id FROM db WHERE name='%s'";
    $sql_insert_prop   = "INSERT INTO {dbxrefprop} (dbxref_id,type_id,value,rank) VALUES (%d,$is_a_term_id,'%s',%d)";
    $sql_check_prop   = "SELECT dbxrefprop_id as id from {dbxrefprop} where dbxref_id=%d and type_id=$is_a_term_id and value='%s'";
    $sql_prop_rank   = "SELECT max(rank) from {dbxrefprop} where dbxref_id=%d and type_id=$is_a_term_id";
    $sql_check         = "SELECT dbxref_id as id FROM dbxref WHERE accession='%s' AND db_id=%d";
    if (empty($dbxref_descr)){
      $sql_insert_dbxref = "INSERT INTO dbxref (accession,db_id) VALUES ('%s',%d)";
    }else{
      $sql_insert_dbxref = "INSERT INTO dbxref (accession,db_id,description) VALUES ('%s',%d,'%s')";
    }
  }
  $res = db_fetch_array(db_query($sql_select_db, $db));
  $db_id = $res['db_id'];
  if (empty($db_id)) {
    db_query($sql_insert_db, $db);
    $res = db_fetch_array(db_query($sql_select_db, $db));
    $db_id = $res['db_id'];
  }
  if (empty($db_id)) {
    gmod_dbsf_drupal_set_message(
    gmod_dbsf_t('There has been a problem inserting a new external database reference. Are you sure permissions are properly set?'),
     'error', FALSE);
    return FALSE;
  }
  if (!empty($db_descr) ){
    db_query($sql_update_dbdescr, $db_descr,$db_id);
  }if (!empty($db_urlprefix)){
    db_query($sql_update_urlprefix, $db_urlprefix,$db_id);
  }if (!empty($db_url)){
    db_query($sql_update_url, $db_url,$db_id);
  }
  foreach ($dbxref_array as $index=>$dbxref) {
    $dbxref_res = db_fetch_array(db_query($sql_check, $dbxref, $db_id));
    if (empty($dbxref_res['id'])) {
      if (empty($dbxref_descr[$index])){
        db_query($sql_insert_dbxref, $dbxref, $db_id);
      }else{
        db_query($sql_insert_dbxref, $dbxref, $db_id, $dbxref_descr[$index]);
      }
      $dbxref_res = db_fetch_array(db_query($sql_check, $dbxref, $db_id));
    }elseif(!empty($dbxref_descr[$index]) && empty($noupdate)){
      db_query($sql_update_dbxrefdescr,$dbxref_descr[$index],$dbxref_res['id']);
    }
    if (!empty($dbxref_properties[$index])){
      foreach ($dbxref_properties[$index] as $prop){
        $prop=check_plain($prop);
        if (empty($prop)){continue;}
        $prop_check = db_fetch_array(db_query($sql_check_prop,$dbxref_res['id'],$prop));
        if (empty($prop_check['id'])){
          $rank_data = db_fetch_array(db_query($sql_prop_rank,$dbxref_res['id']));
          $rank = !empty($rank_data['max']) ? $rank_data['max']+1:1;
          db_query($sql_insert_prop,$dbxref_res['id'],$prop,$rank);
        }
      }
    }
  }
  return $db_id;
}

function gmod_dbsf_delete_db($db, $dbxref_array = NULL) {
  if (empty($db)) {
    return FALSE;
  }
  $sql_delete1   = '';
  $sql_check1    = '';
  $sql_delete2   = '';
  $sql_check2    = '';
  $sql_select_db = '';
  $is_chado      = gmod_dbsf_is_chado();
  if ($is_chado === FALSE) {
    $sql_select_db = "SELECT db_id FROM {gmod_dbsf_db} as db WHERE name='%s'";
    $sql_delete1b   = "DELETE FROM {gmod_dbsf_db} WHERE db_id=%d";
    $sql_check1    = "SELECT db_id as id FROM {gmod_dbsf_db} as db WHERE db_id=%d";
    $sql_delete2b   = "DELETE FROM {gmod_dbsf_dbxref} WHERE db_id=%d AND accession IN (%s)";
    $sql_check2    = "SELECT dbxref_id as id FROM {gmod_dbsf_dbxref} as dbxref WHERE db_id=%d AND accession IN (%s)";
  }
  else {
    // It is a Chado database; Chado has no prefixes (and Drupal has a bug when one db has a prefix)
    $sql_select_db = "SELECT db_id FROM db WHERE name='%s'";
    $sql_delete1b   = "DELETE FROM db WHERE db_id=%d";
    $sql_check1    = "SELECT db_id as id FROM db WHERE db_id=%d";
    $sql_delete2b   = "DELETE FROM dbxref WHERE db_id=%d AND accession IN (%s)";
    $sql_delete1a   = "DELETE FROM dbxrefprop WHERE dbxref_id IN (SELECT dbxref_id from dbxref where db_id=%d)";
    $sql_delete2a   = "DELETE FROM dbxrefprop WHERE dbxref_id IN (SELECT dbxref_id from dbxref where db_id=%d AND accession=(%s))";
    $sql_check2    = "SELECT dbxref_id as id FROM dbxref WHERE db_id=%d  AND accession IN (%s)";
  }
  $db_id =0;
  if (is_numeric($db)){
    $db_id =$db;
  }else{
    $res = db_fetch_array(db_query($sql_select_db, $db));
    $db_id = $res['db_id'];
  }
  if (empty($db_id)) {
    // does not exist
    return TRUE;
  }
  if (empty($dbxref_array)) {
    //delete entire db
    if (!empty($sql_delete1a)){
      db_query($sql_delete1a, $db_id);
    }
    db_query($sql_delete1b, $db_id);
    $res = db_fetch_array(db_query($sql_check1, $db_id));
    if (!empty($res['id'])) {
      drupal_set_message(t('There has been a problem deleting your external database reference %db. Are you sure permissions are properly set?', array('%db' => $db)), 'error', FALSE);
      return FALSE;
    }
  }
  else {
    $dbxref_str = gmod_dbsf_array2csv($dbxref_array);
    if (!empty($sql_delete2a)){
      db_query($sql_delete2a, $db_id, $dbxref_str);
    }
    db_query($sql_delete2b, $db_id, $dbxref_str);
    $res = db_fetch_array(db_query($sql_check1, $db_id, $dbxref_str));
    if (!empty($res['id'])) {
      drupal_set_message(t('There has been a problem deleting your external database reference %db. Are you sure permissions are properly set?', array('%db' => $db)), 'error', FALSE);
      return FALSE;
    }
  }
  return TRUE;
}


/**
 * Populate a CV table using a CV name and a list of CVTERMS
 *
 * Can be used with a Chado or Drupal database
 *
 * @param $cv
 *   Name of CV
 * @param $cvterm_array
 *   A list array of cvterm names to add
 *
 * @return
 *   FALSE on failure, the (int) cv_id on success
 */
function gmod_dbsf_add_cv($cv, $cvterm_array,$cvdef=NULL,$cvterm_def=NULL,$cvterm_properties=NULL) {
  if (empty($cv) || empty($cvterm_array)) {
    return FALSE;
  }
  $sql_insert_cv     = '';
  $sql_select_cv     = '';
  $sql_check         = '';
  $sql_insert_cvterm = '';
  $sql_insert_prop ='';
  $is_a_term_id = gmod_dbsf_get_add_cv_withnames('relationship','is_a');
  $is_chado          = gmod_dbsf_is_chado();
  if ($is_chado === FALSE) {
    $sql_insert_cv     = "INSERT INTO {gmod_dbsf_cv} (name) VALUES ('%s')";
    $sql_update_cvdef  = "UPDATE {gmod_dbsf_cv} set definition='%s' where cv_id=%d";
    $sql_select_cv     = "SELECT cv_id FROM {gmod_dbsf_cv} as cv WHERE name='%s'";
    $sql_check         = "SELECT cvterm_id as id FROM {gmod_dbsf_cvterm} as cvterm WHERE name='%s' AND cv_id=%d";
    $sql_update_cvtermdef ='';
    if (empty($cvterm_def)){
      $sql_insert_cvterm = "INSERT INTO {gmod_dbsf_cvterm} (name,cv_id,dbxref_id) VALUES ('%s',%d,%d)";
    }else{
      $sql_insert_cvterm = "INSERT INTO {gmod_dbsf_cvterm} (name,cv_id,dbxref_id,definition) VALUES ('%s',%d,%d,'%s')";
    }
  }
  else {
    // It is a Chado database; Chado has no prefixes (and Drupal has a bug when one db has a prefix)
    $sql_insert_cv     = "INSERT INTO cv (name) VALUES ('%s')";
    $sql_update_cvdef  = "UPDATE {cv} set definition='%s' where cv_id=%d";
    $sql_update_cvtermdef  = "UPDATE {cvterm} set definition='%s' where cvterm_id=%d";
    $sql_select_cv     = "SELECT cv_id FROM cv WHERE name='%s'";
    $sql_check         = "SELECT cvterm_id as id FROM cvterm WHERE name='%s' AND cv_id=%d";
    $sql_check_prop   = "SELECT cvtermprop_id as id from {cvtermprop} where cvterm_id=%d and type_id=$is_a_term_id and value='%s'";
    $sql_insert_prop   = "INSERT INTO {cvtermprop} (cvterm_id,type_id,value,rank) VALUES (%d,$is_a_term_id,'%s',%d)";
    $sql_prop_rank   = "SELECT max(rank) from {cvtermprop} where cvterm_id=%d and type_id=$is_a_term_id";
    if (empty($cvterm_def)){
      $sql_insert_cvterm = "INSERT INTO cvterm (name,cv_id,dbxref_id) VALUES ('%s',%d,%d)";
    }else{
      $sql_insert_cvterm = "INSERT INTO cvterm (name,cv_id,dbxref_id,definition) VALUES ('%s',%d,%d,'%s')";
    }
  }

  $res = db_fetch_array(db_query($sql_select_cv, $cv));
  $cv_id = $res['cv_id'];
  if (empty($cv_id)) {
    db_query($sql_insert_cv, $cv);
    $res = db_fetch_array(db_query($sql_select_cv, $cv));
    $cv_id = $res['cv_id'];
  }
  if (empty($cv_id)) {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('There has been a problem inserting a new controlled vocabulary. Are you sure permissions are properly set?'), 'error', FALSE);
    return FALSE;
  }
  if (!empty($cvdef)){
    db_query($sql_update_cvdef, $cvdef,$cv_id);
  }
  foreach ($cvterm_array as $index=>$cvterm) {
    $dbxref_id = gmod_dbsf_get_add_dbxref_withnames('null', "local:$cv:$cvterm");
    $cvterm_res = db_fetch_array(db_query($sql_check, $cvterm, $cv_id));
    if (empty($cvterm_res['id'])) {
      if(!empty($cvterm_def[$index]) && !empty($sql_update_cvtermdef)){
        db_query($sql_update_cvtermdef,$cvterm_def[$index],$res['id']);
      }else{
        db_query($sql_insert_cvterm, $cvterm, $cv_id, $dbxref_id);
      }
      $cvterm_res = db_fetch_array(db_query($sql_check, $cvterm, $cv_id));
    }
    if (!empty($cvterm_properties[$index])){
      foreach ($cvterm_properties[$index] as $prop){
        $prop=check_plain($prop);
        if (empty($prop)){next;}
        $prop_check = db_fetch_array(db_query($sql_check_prop,$cvterm_res['id'],$prop));
        if (!empty($prop_check)){
          $rank_data = db_fetch_array(db_query($sql_prop_rank,$cvterm_res['id']));
          $rank = !empty($rank_data['max']) ? $rank_data['max']+1:1;
          db_query($sql_insert_prop,$cvterm_res['id'],$prop,$rank);
        }
      }
    }
  }
  foreach ($cvterm_array as $index=>$cvterm) {
    $dbxref_id = gmod_dbsf_get_add_dbxref_withnames('null', "local:$cv:$cvterm");
    $res = db_fetch_array(db_query($sql_check, $cvterm, $cv_id));
    if (empty($res['id'])) {
      db_query($sql_insert_cvterm, $cvterm, $cv_id, $dbxref_id,$cvterm_def[$index]);
      $res = db_fetch_array(db_query($sql_check, $cvterm, $cv_id));
    }elseif(!empty($sql_update_cvtermdef)){
      db_query($sql_update_cvtermdef,$cvterm_def[$index],$res['id']);
    }
    if (!empty($res['id']) && !empty($cvterm_properties)){
      foreach ($cvterm_properties as $prop){
        $rank_data = db_fetch_array(db_query($sql_prop_rank,$res['id']));
        $rank = !empty($rank_data['max']) ? $rank_data['max']+1:1;
        db_query($sql_insert_prop,$res['id'],$prop,$rank);
      }
    }
  }
  return $cv_id;
}

/**
 * Delete an entire CV or specific terms
 *
 * @param $cv
 * CV to delete
 * @param $cvterm_array
 * If present, only delete these terms FROM $cv
 *
 * @return
 * TRUE on success
 */
function gmod_dbsf_delete_cv($cv, $cvterm_array = NULL) {
  if (empty($cv)) {
    return FALSE;
  }
  $sql_delete1   = '';
  $sql_check1    = '';
  $sql_delete2   = '';
  $sql_check2    = '';
  $sql_select_cv = '';
  $is_chado      = gmod_dbsf_is_chado();
  if ($is_chado === FALSE) {
    $sql_select_cv = "SELECT cv_id FROM {gmod_dbsf_cv} as cv WHERE name='%s'";
    $sql_delete1   = "DELETE FROM {gmod_dbsf_cv} WHERE cv_id=%d";
    $sql_check1    = "SELECT cv_id as id FROM {gmod_dbsf_cv} as cv WHERE cv_id=%d";
    $sql_delete2   = "DELETE FROM {gmod_dbsf_cvterm} WHERE cv_id=%d AND name IN (%s)";
    $sql_check2    = "SELECT cvterm_id as id FROM {gmod_dbsf_cvterm} as cvterm WHERE cv_id=%d AND name IN (%s)";
  }
  else {
    // It is a Chado database; Chado has no prefixes (and Drupal has a bug when one db has a prefix)
    $sql_select_cv = "SELECT cv_id FROM cv WHERE name='%s'";
    $sql_delete1   = "DELETE FROM cv WHERE cv_id=%d";
    $sql_check1    = "SELECT cv_id as id FROM cv WHERE cv_id=%d";
    $sql_delete2   = "DELETE FROM cvterm WHERE cv_id=%d AND name IN (%s)";
    $sql_check2    = "SELECT cvterm_id as id FROM cvterm WHERE cv_id=%d  AND name IN (%s)";
    $sql_delete3   = "DELETE FROM cvtermprop WHERE cvterm_id IN (SELECT cvterm_id from cvterm where cv_id=%d AND name IN (%s))";
    $sql_delete4   = "DELETE FROM cvtermprop WHERE cvterm_id IN (SELECT cvterm_id from cvterm where cv_id=%d)";
  }
  $cv_id =0;
  if (is_numeric($cv)){
    $cv_id =$cv;
  }else{
    $res = db_fetch_array(db_query($sql_select_cv, $cv));
    $cv_id = $res['cv_id'];
  }
  if (empty($cv_id)) {
    // does not exist
    gmod_dbsf_drupal_set_message("Cannot find CV $cv",'error');
    return FALSE;
  }
  if (empty($cvterm_array)) {
    //delete entire cv
    db_query($sql_delete4,$cv_id);
    db_query($sql_delete1, $cv_id);
    $res = db_fetch_array(db_query($sql_check1, $cv_id));
    if (!empty($res['id'])) {
      gmod_dbsf_drupal_set_message(t('There has been a problem deleting your controlled vocabulary %cv. Are you sure permissions are properly set?', array('%cv' => $cv)), 'error', FALSE);
      return FALSE;
    }
  }
  else {
    $cvterm_str = gmod_dbsf_array2csv($cvterm_array);
    db_query($sql_delete2, $cv_id, $cvterm_str);
    $res = db_fetch_array(db_query($sql_check1, $cv_id, $cvterm_str));
    if (!empty($res['id'])) {
      gmod_dbsf_drupal_set_message(t('There has been a problem deleting your controlled vocabulary %cv. Are you sure permissions are properly set?', array('%cv' => $cv)), 'error', FALSE);
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Populate a IC Chado property table
 *
 * This function allows you to populate a property table of feature,
 * resource, organism, library or software type in Chado or Drupal.
 *
 *
 * @param $table_type
 *   Type of table linked to the -prop table.
 *   Currently only organism, library, software, feature and resource are allowed
 * @param $object_name
 *   Name or ID of reference feature/resource etc
 * @param $cvterm_id
 *   CV term ID used to link the property
 * @param $property_array
 *   An array of property values to insert with the above cvterm and reference
 *
 * @return
 *   FALSE on failure, TRUE on success
 */
function gmod_dbsf_populate_prop($table_type, $object_name, $cvterm_id, $property_array) {
  if (empty($table_type) || empty($object_name) || empty($cvterm_id) || empty($property_array)) {
    return FALSE;
  }
  $key        = '';
  $table_pkey = '';
  $table_name = '';
  if ($table_type == 'resource') {
    $key        = 'resource_id';
    $table_pkey = 'resourceprop_id';
    $table_name = 'resourceprop';
  }
  elseif ($table_type == 'organism') {
    $key        = 'organism_id';
    $table_pkey = 'organismprop_id';
    $table_name = 'organismprop';
  }
  elseif ($table_type == 'feature') {
    $key        = 'feature_id';
    $table_pkey = 'featureprop_id';
    $table_name = 'featureprop';
  }
  elseif ($table_type == 'library') {
    $key        = 'library_id';
    $table_pkey = 'libraryprop_id';
    $table_name = 'libraryprop';
  }
  elseif ($table_type == 'software') {
    $key        = 'software_id';
    $table_pkey = 'softwareprop_id';
    $table_name = 'softwareprop';
  }
  else {
    drupal_set_message(t('Currently only organism, software, library, resource AND feature table types are allowed'), 'error', FALSE);
    return FALSE;
  }
  $is_chado = gmod_dbsf_is_chado();
  if (is_numeric($object_name)) {
    $object_id = $object_name;
  }
  else {
    $object_select = '';
    if ($is_chado === FALSE) {
      $object_select = "SELECT $key FROM {gmod_dbsf_". $table_type ."} as $table_type WHERE uniquename='%s'";
    }
    else {
      $object_select = "SELECT $key FROM $table_type WHERE uniquename='%s'";
    }
    $res = db_fetch_array(db_query($object_select, $object_name));
    $object_id = $res[$key];
  }
  if (empty($object_id)) {
    drupal_set_message(t('Failed to get %key for %object_name. Are you sure it exists?', array('%key' => $key, '%object_name' => $object_name)), 'error', FALSE);
    return FALSE;
  }
  $property_check     = '';
  $property_next_rank = '';
  $property_insert    = '';
  if ($is_chado === FALSE) {
    $property_check     = "SELECT $table_pkey FROM {gmod_dbsf_". $table_name ."} as $table_type WHERE $key=%d AND type_id=%d AND value='%s'";
    $property_next_rank = "SELECT max(rank) FROM {gmod_dbsf_". $table_name ."} as $table_type WHERE $key=%d AND type_id=%d ";
    $property_insert    = "INSERT INTO {gmod_dbsf_". $table_name ."} ($key,type_id,value,rank) VALUES (%d,%d,'%s',%d)";
  }
  else {
    $property_check     = "SELECT $table_pkey FROM $table_name WHERE $key=%d AND type_id=%d AND value='%s'";
    $property_next_rank = "SELECT max(rank) FROM $table_name WHERE $key=%d AND type_id=%d ";
    $property_insert    = "INSERT INTO $table_name ($key,type_id,value,rank) VALUES (%d,%d,'%s',%d)";
  }
  foreach ((array)$property_array as $value) {
    $res = db_fetch_array(db_query($property_check, $object_id, $cvterm_id, $value));
    if (empty($res[$table_pkey])) {
      $res_rank = db_fetch_array(db_query($property_next_rank, $object_id, $cvterm_id));
      if (isset($res_rank['max'])) {
        $next_rank = $res_rank['max'] + 1;
      }
      if (empty($next_rank)) {
        $next_rank = 0;
      }
      db_query($property_insert, $object_id, $cvterm_id, $value, $next_rank);
      $res = db_fetch_array(db_query($property_check, $object_id, $cvterm_id, $value));
      if (empty($res[$table_pkey])) {
        drupal_set_message(t('1: Failed to add %value into %table_name. Are you sure %db permissions allow INSERT operations?', array('%value' => $value, '%table_name' => $table_name,'%db'=> $is_chado===FALSE ? 'Drupal DB' : 'Chado DB')), 'error', FALSE);
        return FALSE;
      }
    }
  }
  return TRUE;
}


function gmod_dbsf_populate_dbxrefs($table_type, $object_name, $dbxref_array=NULL){
  if (empty($table_type) || empty($object_name)) {
    return FALSE;
  }
  $key        = '';
  $table_pkey = '';
  $table_name = '';
  if ($table_type == 'feature') {
    $key        = 'feature_id';
    $table_pkey = 'feature_dbxref_id';
    $table_name = 'feature_dbxref';
  }
  else {
    drupal_set_message(t('Currently only feature table types are allowed'), 'error', FALSE);
    return FALSE;
  }
  $is_chado = gmod_dbsf_is_chado();
  $object_id ='';
  // get object id
  if (is_numeric($object_name)) {
    $object_id = $object_name;
  }
  else {
    $object_select = '';
    if ($is_chado === FALSE) {
      $object_select = "SELECT $key FROM {gmod_dbsf_". $table_type ."} as $table_type WHERE uniquename='%s'";
    }
    else {
      $object_select = "SELECT $key FROM $table_type WHERE uniquename='%s'";
    }
    $res = db_fetch_array(db_query($object_select, $object_name));
    $object_id = $res[$key];
    if (empty($object_id)) {
      gmod_dbsf_drupal_set_message(t('Failed to get %key for %object_name. Are you sure it exists?', array('%key' => $key, '%object_name' => $object_name)), 'error', FALSE);
      return FALSE;
    }
  }
  $dbxref_check  = '';
  $dbxref_insert = '';
  $dbxref_insert = '';
  if ($is_chado === FALSE) {
    $dbxref_check = "SELECT $table_pkey FROM {gmod_dbsf_". $table_name ."} as $table_name WHERE $key=$object_id AND "
    . "dbxref_id=%d";
    $dbxref_insert = "INSERT INTO {gmod_dbsf_". $table_name ."} ($key,dbxref_id) VALUES (%d,%d)";
  }
  else {
    $dbxref_check = "SELECT $table_pkey FROM $table_name WHERE $key=$object_id AND " . "dbxref_id=%d";
    $dbxref_insert = "INSERT INTO $table_name ($key,dbxref_id) VALUES ($object_id,%d)";
  }
  foreach ($dbxref_array as $dbxref_id) {
    $res = db_fetch_array(db_query($dbxref_check, $dbxref_id));
    if (empty($res[$table_pkey])) {
      db_query($dbxref_insert, $dbxref_id);
      $res = db_fetch_array(db_query($dbxref_check, $dbxref_id));
      if (empty($res[$table_pkey])) {
        gmod_dbsf_drupal_set_message(t('2: Failed to add %dbxref_id into %table_name. Are you sure %db permissions allow INSERT operations?', array('%dbxref_id' => $dbxref_id, '%table_name' => $table_name,'%db'=> $is_chado===FALSE ? 'Drupal DB' : 'Chado DB')), 'error', FALSE);
        return FALSE;
      }
    }
  }
  gmod_dbsf_drupal_set_message('Database cross-references stored.','warning');
  return TRUE;
}

/**
 * Populate a _cvterm Chado table
 *
 * This function populates a _cvterm table in chado or Drupal
 * The implementation needs a bit cleanup...
 * @see gmod_dbsf_populate_prop
 *
 * @param $table_type
 *   Type of table linked to teh _cvterm table
 *   Currently, only feature and resource table sets are supported
 * @param $object_name
 *   Name of reference feature/resourc
 * @param $cvname
 *   Name of CV to which the cvterms belong to or an array of cvterm_id
 *   @see gmod_dbsf_add_cv()
 * @param $cvterm_array
 *   A list array of cvterms to add to the _cvterm table or null
 *   @see gmod_dbsf_add_cv()
 * @param $pub_id
 * The publication ID or uniquenames which defines how the CVterm was derived
 *
 * @return
 *   FALSE on failure, TRUE on success
 */
function gmod_dbsf_populate_cvterms($table_type, $object_name, $cvname=NULL, $cvterm_array = NULL, $pub_id = NULL,$is_not=FALSE) {
  if (empty($table_type) || empty($object_name)) {
    return FALSE;
  }
  $key        = '';
  $table_pkey = '';
  $table_name = '';
  if ($table_type == 'resource') {
    $key        = 'resource_id';
    $table_pkey = 'resource_cvterm_id';
    $table_name = 'resource_cvterm';
  }
  elseif ($table_type == 'feature') {
    $key        = 'feature_id';
    $table_pkey = 'feature_cvterm_id';
    $table_name = 'feature_cvterm';
  }
  else {
    drupal_set_message(t('Currently only resource or feature table types are allowed'), 'error', FALSE);
    return FALSE;
  }
  $is_chado = gmod_dbsf_is_chado();
  $object_id='';
  // get object id
  if (is_numeric($object_name)) {
    $object_id = $object_name;
  }

  else {
    $object_select = '';
    if ($is_chado === FALSE) {
      $object_select = "SELECT $key FROM {gmod_dbsf_". $table_type ."} as $table_type WHERE uniquename='%s'";
      if (!empty($pub_id) && is_numeric(!$pub_id)) {
        $res = db_fetch_array(dbquery("SELECT pub_id FROM {gmod_dbsf_pub} WHERE uniquename='%s'", $pub_id));
        $pub_id = $res['pub_id'];
      }
    }
    else {
      $object_select = "SELECT $key FROM $table_type WHERE uniquename='%s'";
      if (!empty($pub_id) && is_numeric(!$pub_id)) {
        $res = db_fetch_array(dbquery("SELECT pub_id FROM pub WHERE uniquename='%s'", $pub_id));
        $pub_id = $res['pub_id'];
      }
    }
    $res = db_fetch_array(db_query($object_select, $object_name));
    $object_id = $res[$key];
    if (empty($object_id)) {
      drupal_set_message(t('Failed to get %key for %object_name. Are you sure it exists?', array('%key' => $key, '%object_name' => $object_name)), 'error', FALSE);
      return FALSE;
    }
  }
  $set_is_not_sql = "UPDATE $table_name set is_not=TRUE where $table_pkey=%d";

  //two options:1 $cvname is a string of name of CV and $cvterm_array an array of cvterm names
  if (!is_array($cvname) && is_array($cvterm_array)) {
    // cv
    $cvterm_check  = '';
    $cvterm_insert = '';
    $cvterm_insert = '';
    $cv_id         = gmod_dbsf_add_cv($cvname, $cvterm_array);
    if ($is_chado === FALSE) {
      $cvterm_check = "SELECT $table_pkey FROM {gmod_dbsf_". $table_name ."} as $table_name WHERE $key=$object_id AND " . "cvterm_id=(SELECT cvterm_id FROM {gmod_dbsf_cvterm} as cvterm WHERE cv_id=%d AND name='%s')";
      $cvterm_insert = "INSERT INTO {gmod_dbsf_". $table_name ."} ($key,cvterm_id) VALUES ($object_id," . "(SELECT cvterm_id FROM {gmod_dbsf_cvterm} WHERE cv_id=%d AND name='%s'))";
      if (!empty($pub_id) && is_numeric($pub_id)) {
        $cvterm_insert = "INSERT INTO {gmod_dbsf_". $table_name ."} ($key,cvterm_id,pub_id) VALUES ($object_id,"
        . "(SELECT cvterm_id FROM {gmod_dbsf_cvterm} WHERE cv_id=%d AND name='%s'),%d)";
      }
    }
    else {
      $cvterm_check = "SELECT $table_pkey FROM $table_name WHERE $key=$object_id AND " . "cvterm_id=(SELECT cvterm_id FROM cvterm WHERE cv_id=%d AND name='%s')";
      $cvterm_insert = "INSERT INTO $table_name ($key,cvterm_id) VALUES ($object_id," . "(SELECT cvterm_id FROM cvterm WHERE cv_id=%d AND name='%s'))";
      if (!empty($pub_id) && is_numeric($pub_id)) {
        $cvterm_insert = "INSERT INTO $table_name ($key,cvterm_id,pub_id) VALUES ($object_id," . "(SELECT cvterm_id FROM cvterm WHERE cv_id=%d AND name='%s'),%d)";
      }
    }

    foreach ($cvterm_array as $cvterm_name) {
      $res = db_fetch_array(db_query($cvterm_check, $cv_id, $cvterm_name));
      if (empty($res[$table_pkey])) {
        db_query($cvterm_insert, $cv_id, $cvterm_name);
        $res = db_fetch_array(db_query($cvterm_check, $cv_id, $cvterm_name));
        if (empty($res[$table_pkey])) {
          drupal_set_message(t('3: Failed to add %cvterm_name into %table_name. Are you sure %db permissions allow INSERT operations?', array('%cvterm_name' => $cvterm_name, '%table_name' => $table_name,'%db'=> $is_chado===FALSE ? 'Drupal DB' : 'Chado DB')), 'error', FALSE);
          return FALSE;
        }
        if (!empty($comment)){
          db_query($set_is_not_sql,$res[$table_pkey]);
        }

      }
    }
    return TRUE;
  }
  //option two: $cvname is an array of cvterm IDs. Much simpler. THis was added later and I was too lazy to fix it in all the other functions
  elseif (is_array($cvname)) {
    $cvterm_check  = '';
    $cvterm_insert = '';
    $cvterm_insert = '';
    if ($is_chado === FALSE) {
      $cvterm_check = "SELECT $table_pkey FROM {gmod_dbsf_". $table_name ."} as $table_name WHERE $key=$object_id AND " . "cvterm_id=%d";
      $cvterm_insert = "INSERT INTO {gmod_dbsf_". $table_name ."} ($key,cvterm_id) VALUES (%d,%d)";
      if (!empty($pub_id) && is_numeric($pub_id)) {
        $cvterm_insert = "INSERT INTO {gmod_dbsf_". $table_name ."} ($key,cvterm_id,pub_id) VALUES ($object_id,%d,$pub_id)";
      }
    }
    else {
      $cvterm_check = "SELECT $table_pkey FROM $table_name WHERE $key=$object_id AND " . "cvterm_id=%d";
      $cvterm_insert = "INSERT INTO $table_name ($key,cvterm_id) VALUES (%d,%d)";
      if (!empty($pub_id) && is_numeric($pub_id)) {
        $cvterm_insert = "INSERT INTO $table_name ($key,cvterm_id,pub_id) VALUES ($object_id,%d,$pub_id)";
      }
    }
    foreach ($cvname as $cvterm_id) {
      $res = db_fetch_array(db_query($cvterm_check, $cvterm_id));
      if (empty($res[$table_pkey])) {
        db_query($cvterm_insert, $cvterm_id);
        $res = db_fetch_array(db_query($cvterm_check, $cvterm_id));
        if (empty($res[$table_pkey])) {
          drupal_set_message(t('4: Failed to add %cvterm_id into %table_name. Are you sure %db permissions allow INSERT operations?', array('%cvterm_id' => $cvterm_id, '%table_name' => $table_name,'%db'=> $is_chado===FALSE ? 'Drupal DB' : 'Chado DB')), 'error', FALSE);
          return FALSE;
        }
        if (!empty($comment)){
          db_query($set_is_not_sql,$res[$table_pkey]);
        }
      }
    }
    return TRUE;
  }
}

/**
 * Get cvterm_id for a CV, add it first if it does not exist.
 *
 * If $cvterm_name (second argument) is not given, it will return all cvterm_id/cvterm_names
 * for the CV specified in $cv_name (first arg). $name_as_key controls the return array
 * @see gmod_dbsf_get_add_dbxref_withnames
 *
 * @param $cv_name
 *   The name of the CV to which the cvterm belong.
 * @param $cvterm_name
 *   The name of the cvterm to look for or add. Not needed if just want to
 *   retrieve all cvterms
 * @param $name_as_key
 *   TRUE, FALSE or BOTH. False gives cvterm_id as key to return array;
 *   TRUE gives name with ID as value; BOTH gives name both as key
 *   and value (useful for FAPI)
 * @param $definition
 * if provided, then it updates the definition for the added term if there is
 * none stored currently
 * @param $force_update_def
 * If true, then definition is updated even if was not empty
 *
 * @return
 *   FALSE on failure.
 *   If cvterm has been provided, then an integer of the cvterm_id is returned.
 *   If no cvterm, then return is an associative array WHERE keys are controlled
 *   by $name_as_key.
 */
function gmod_dbsf_get_add_cv_withnames($cv_name, $cvterm_name = NULL, $name_as_key = FALSE, $definition = NULL, $force_update_def = FALSE) {
  //returned only if $cvterm_name is empty
  $return_array = array();
  // returned if cvterm_name is given
  $cvterm_id = '';

  if (empty($cv_name)) {
    return $return_array;
  }
  $update_cvterm_def = '';
  $select_cvterm_def = '';
  $select_cvterms    = '';
  $select_cv_id      = '';
  $insert_cv_id      = '';
  $insert_cvterm     = '';
  $select_cvterm     = '';
  $check_cvterm      = '';
  $check_cv          = '';
  $is_chado          = gmod_dbsf_is_chado();
  if ($is_chado === FALSE) {
    $select_cvterms    = 'SELECT cvterm_id,name,definition FROM {gmod_dbsf_cvterm} as cvterm WHERE cv_id=' . "(SELECT cv_id FROM {gmod_dbsf_cv} as cv WHERE name='%s') ORDER BY name";
    $select_cv_id      = "SELECT cv_id FROM {gmod_dbsf_cv} as cv WHERE name='%s'";
    $insert_cv_id      = "INSERT INTO {gmod_dbsf_cv} (name) VALUES ('%s')";
    $insert_cvterm     = "INSERT INTO {gmod_dbsf_cvterm} (name,cv_id,dbxref_id) VALUES ('%s',%d,%d)";
    $select_cvterm     = 'SELECT cvterm_id FROM {gmod_dbsf_cvterm} as cvterm JOIN {gmod_dbsf_cv} as cv ON cvterm.cv_id=cv.cv_id ' . " WHERE cvterm.name='%s' AND cv.name='%s'";
    $check_cvterm      = "SELECT cvterm_id FROM {gmod_dbsf_cvterm} as cvterm WHERE cvterm.name='%s' AND cv_id=%d";
    $update_cvterm_def = "UPDATE {gmod_dbsf_cvterm} set definition='%s' WHERE cvterm_id=%d";
  }
  else {
    // It is a Chado database; Chado has no prefixes (and Drupal has a bug when one db has a prefix). TODO; verify this bug still exists
    $select_cvterms    = 'SELECT cvterm_id,name,definition  FROM cvterm WHERE cv_id=' . "(SELECT cv_id FROM cv WHERE name='%s') ORDER BY name";
    $select_cv_id      = "SELECT cv_id FROM cv WHERE name='%s'";
    $insert_cv_id      = "INSERT INTO cv (name) VALUES ('%s')";
    $insert_cvterm     = "INSERT INTO cvterm (name,cv_id,dbxref_id) VALUES ('%s',%d,%d)";
    $select_cvterm     = 'SELECT cvterm_id FROM cvterm JOIN cv ON cvterm.cv_id=cv.cv_id ' . " WHERE cvterm.name='%s' AND cv.name='%s'";
    $check_cvterm      = "SELECT cvterm_id FROM cvterm WHERE cvterm.name='%s' AND cv_id=%d";
    $update_cvterm_def = "UPDATE cvterm set definition='%s' WHERE cvterm_id=%d";
  }

  $check = db_fetch_array(db_query($select_cv_id,$cv_name));
  if (empty($check)){
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('There is no CV %cv_name in your database.', array('%cv_name' => $cv_name)), 'error', FALSE);
    return $return_array;
  }
  if (empty($cvterm_name)) {
    //this is for getting all the cvterms in a cv
    $res = db_query($select_cvterms, $cv_name);
    if (empty($res)) {
      return $return_array;
    }

    while ($row = db_fetch_array($res)) {
      if (!empty($name_as_key) && $name_as_key === 'BOTH') {
        $return_array[$row['name']] = $row['name'];
      }elseif (!empty($name_as_key) && $name_as_key === 'FRIENDLY') {
        $return_array[$row['cvterm_id']] = $row['name'].' - '.$row['definition'];
      }elseif (!empty($name_as_key)) {
        $return_array[$row['name']] = $row['cvterm_id'];
      }
      else {
        $return_array[$row['cvterm_id']] = $row['name'];
      }
    }
    // this function has now ended for fetching entire cv
    return $return_array;
  }
  //cvterm is provided.
  if (is_array($cvterm_name)){
    $return_array = array();
    foreach ($cvterm_name as $name){
      $res       = db_fetch_array(db_query($select_cvterm, $name, $cv_name));
      $cvterm_id = $res['cvterm_id'];
      if (!empty($cvterm_id)) {
          $return_array[$cvterm_id]=$name;
        }
      }
   return $return_array;
  }else{
    $cvterm_id = 0;
    $res       = db_fetch_array(db_query($select_cvterm, $cvterm_name, $cv_name));
    $cvterm_id = $res['cvterm_id'];
    if (!empty($cvterm_id)) {
    //cvterm id already exists
      if (!empty($definition)){
        if ($force_update_def ===TRUE || empty($res['definition'])){
          db_query($update_cvterm_def,$definition,$cvterm_id);
        }
      }
      return $cvterm_id;
    }
  }
  // Ok, so CVTERM did not exist. so add it.
  // does cv exist?
  $cv_id = '';
  $res   = db_fetch_array(db_query($select_cv_id, $cv_name));
  $cv_id = $res['cv_id'];
  if (empty($cv_id)) {
    //add it
    db_query($insert_cv_id, $cv_name);
    $res = db_fetch_array(db_query($select_cv_id, $cv_name));
    $cv_id = $res['cv_id'];
  }
  if (empty($cv_id)) {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('I was not able to store the CV data for %cv_name.', array('%cv_name' => $cv_name)), 'error', FALSE);
    return FALSE;
  }
  //add cvterm
  $dbxref_id = gmod_dbsf_get_add_dbxref_withnames($cv_name, $cvterm_name);

  db_query($insert_cvterm, $cvterm_name, $cv_id, $dbxref_id);
  $res = db_fetch_array(db_query($check_cvterm, $cvterm_name, $cv_id));
  $cvterm_id = $res['cvterm_id'];
  if (!empty($cvterm_id)) {
    if (!empty($definition)){
      if ($force_update_def ===TRUE || empty($res['definition'])){
        db_query($update_cvterm_def,$definition,$cvterm_id);
      }
    }
    return $cvterm_id;
  }
  else {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('I was not able to store the cvterm data for %cvterm_name.', array('%cvterm_name' => $cvterm_name)), 'error', FALSE);
    return FALSE;
  }
}

/**
 * Get dbxref_id for a dbxref; add it first if it doesn't exist
 *
 * If $accession is not given, it returns all dbxref_id and names for the
 * database you specify with $dbname
 * @see gmod_dbsf_get_add_cv_withnames
 *
 * @param $dbname
 *   Name of db to link dbxref
 * @param $accession
 *   Accession/uniquename for dbxref to get and/or add. If empty
 *   return all accessions for $dbname
 * @param $name_as_key
 *   TRUE, FALSE or BOTH. False gives cvterm_id as key to return array;
 *   TRUE gives name with ID as value; BOTH gives name both as key
 *   and value (useful for FAPI)
 *
 * @return
 *   FALSE on failure or an integer with the dbxref_id on success.
 */
function gmod_dbsf_get_add_dbxref_withnames($dbname, $accession = NULL, $description = NULL, $name_as_key = NULL) {
  if (empty($dbname)) {
    return FALSE;
  }
  $is_chado = gmod_dbsf_is_chado();

  if (empty($accession)) {
    $select_dbxrefs = '';
    //this is for getting all the dbxrefs in a db
    if ($is_chado === FALSE) {
      $select_dbxrefs = 'SELECT dbxref_id,accession,description FROM {gmod_dbsf_dbxref} as dbxref WHERE db_id='
      . "(SELECT db_id FROM {gmod_dbsf_db} as db WHERE name='%s') ORDER BY accession";
    }
    else {
      $select_dbxrefs = 'SELECT dbxref_id,accession,description FROM dbxref WHERE db_id='
      . "(SELECT db_id FROM db WHERE name='%s') ORDER BY accession";
    }
    $res = db_query($select_dbxrefs, $dbname);
    if (empty($res)) {
      return FALSE;
    }
    while ($row = db_fetch_array($res)) {
      if (!empty($name_as_key) && $name_as_key === 'BOTH') {
        $return_array[$row['accession']] = $row['accession'];
      }
      elseif (!empty($name_as_key) && $name_as_key === 'FRIENDLY') {
        $return_array[$row['dbxref_id']] = $row['accession'].' - '.$row['description'];
      }
      elseif (!empty($name_as_key)) {
        $return_array[$row['accession']] = $row['dbxref_id'];
      }
      else {
        $return_array[$row['dbxref_id']] = $row['accession'];
      }
    }
    if (!empty($return_array)) {
      return $return_array;
    }
    else {
      gmod_dbsf_drupal_set_message(gmod_dbsf_t('Cannot find any data for database %dbname', array('%dbname' => $dbname)), 'error');
      return FALSE;
    }
  }
  // otherwise get a single dbxref
  $dbxref_id = '';
  $select_dbxref = '';
  if ($is_chado === FALSE) {
    $select_dbxref  = 'SELECT dbxref_id FROM {gmod_dbsf_dbxref} as dbxref JOIN {gmod_dbsf_db} as db ON dbxref.db_id=db.db_id ' . " WHERE dbxref.accession='%s' AND db.name='%s'";
    $check_dbxref   = "SELECT dbxref_id FROM {gmod_dbsf_dbxref} as dbxref WHERE accession='%s' AND db_id=%d ";
    $select_db_id   = "SELECT db_id FROM {gmod_dbsf_db} as db WHERE name='%s'";
    $insert_db_id   = "INSERT INTO {gmod_dbsf_db} (name) VALUES ('%s')";
    $insert_dbxref1 = "INSERT INTO {gmod_dbsf_dbxref} (accession,db_id,description) VALUES ('%s',%d,'%s')";
    $insert_dbxref2 = "INSERT INTO {gmod_dbsf_dbxref} (accession,db_id) VALUES ('%s',%d)";
  }
  else {
    $select_dbxref  = 'SELECT dbxref_id FROM dbxref JOIN db ON dbxref.db_id=db.db_id ' . " WHERE dbxref.accession='%s' AND db.name='%s'";
    $check_dbxref   = "SELECT dbxref_id FROM dbxref WHERE accession='%s' AND db_id=%d ";
    $select_db_id   = "SELECT db_id FROM db WHERE name='%s'";
    $insert_db_id   = "INSERT INTO db (name) VALUES ('%s')";
    $insert_dbxref1 = "INSERT INTO dbxref (accession,db_id,description) VALUES ('%s',%d,'%s')";
    $insert_dbxref2 = "INSERT INTO dbxref (accession,db_id) VALUES ('%s',%d)";
  }
  $res = db_fetch_array(db_query($select_dbxref, $accession, $dbname));
  $dbxref_id = $res['dbxref_id'];
  if (!empty($dbxref_id)) {
    return ($dbxref_id);
  }
  else {
    // does db exist?
    $db_id = '';
    $res   = db_fetch_array(db_query($select_db_id, $dbname));
    $db_id = $res['db_id'];
    if (empty($db_id)) {
      //add it

      db_query($insert_db_id, $dbname);
      $res = db_fetch_array(db_query($select_db_id, $dbname));
      $db_id = $res['db_id'];
    }
    if (empty($db_id)) {
      gmod_dbsf_drupal_set_message(gmod_dbsf_t('I was not able to store the db data for %dbname.', array('%dbname' => $dbname)), 'error', FALSE);
      return FALSE;
    }
    //add dbxref
    if (!empty($description)) {
      db_query($insert_dbxref1, $accession, $db_id, $description);
    }
    else {
      db_query($insert_dbxref2, $accession, $db_id);
    }
    $res = db_fetch_array(db_query($check_dbxref, $accession, $db_id));

    $dbxref_id = $res['dbxref_id'];
    if (!empty($dbxref_id)) {
      return $dbxref_id;
    }
    else {
      gmod_dbsf_drupal_set_message(gmod_dbsf_t('I was not able to store the dbxref data for %accession.', array('%accession' => $accession)), 'error', FALSE);
      return FALSE;
    }
  }
}

/** Get a list of pubs, replace or add a new one
 *
 * @param $pub_type_category
 * what kind of publication you're aiming to add, governs which CV is used.
 * Currently 'annotation' sets CV as Evidence Codes and 'dbxref' sets CV as
 * publications
 * @param $type_name
 *   Name of the cvterm which defines the pub type
 * @param $data
 *   (optional) An assoc. array to limit SELECT queries: the keys are used as
 *   column and values as the condition. Further, when adding/replacing,
 *   $data has to contain keys with 'uniquename' and 'dbxref_name'
 * @param $add
 *  Switch which can be FALSE/NULL, ADD, DELETE or REPLACE
 * @param $name_as_key
 *   A boolean. If TRUE the return array has uniquename as keys and
 *   pub_id as values.
 *
 * @return
 *   An associative array with pub_id as the keys and uniquename as values.
 *   Or FALSE on failure.
 */
function gmod_dbsf_get_add_pub($pub_type_category, $type_name, $data = NULL, $add = FALSE, $name_as_key = FALSE) {
  if (empty($type_name) || empty($pub_type_category)) {
    return FALSE;
  }
  //TODO: Needs more work to fully support publications
  /*
  pub_id      | integer                | not null default nextval('pub_pub_id_seq'::regclass)
  title       | text                   |
  volumetitle | text                   |
  volume      | character varying(255) |
  series_name | character varying(255) |
  issue       | character varying(255) |
  pyear       | character varying(255) |
  pages       | character varying(255) |
  miniref     | character varying(255) |
  uniquename  | text                   | not null
  type_id     | integer                | not null
  is_obsolete | boolean                | default false
  publisher   | character varying(255) |
  pubplace    | character varying(255) |
  */


  $is_chado     = gmod_dbsf_is_chado();
  $return_array = array();
  $cv_name      = '';
  $type_id      = 0;
  switch ($pub_type_category) {
    case 'annotation':
      $cv_name = 'Evidence Codes';
      break;

    case 'dbxref':
      $cv_name = 'publications';
      break;
  }
  if (empty($cv_name)) {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('Unrecognised publication type.'), 'error');
    return FALSE;
  }
  $type_id = gmod_dbsf_get_add_cv_withnames($cv_name, $type_name);
  if (empty($type_id)) {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('Could not get cvterm for %type_name', array('%type_name' => $type_name)), 'error');
    return FALSE;
  }
  $sql_select = '';
  $sql_delete = '';
  $sql_insert = '';
  $sql_check  = '';
  if ($is_chado === FALSE) {
    $sql_select = "SELECT pub_id,uniquename FROM {gmod_dbsf_pub} as pub WHERE type_id=$type_id ";
    $sql_delete = "DELETE FROM {gmod_dbsf_pub} WHERE uniquename='%s' CASCADE";
    $sql_insert = "INSERT into {gmod_dbsf_pub} (type_id,uniquename,title) VALUES ($type_id,'%s','%s')";
    $sql_check  = "SELECT pub_id FROM {gmod_dbsf_pub} as pub WHERE uniquename='%s'";
  }
  else {
    $sql_select = "SELECT pub_id,uniquename FROM pub WHERE type_id=$type_id ";
    $sql_delete = "DELETE FROM pub WHERE uniquename='%s' CASCADE";
    $sql_insert = "INSERT into pub (type_id,uniquename,title) VALUES ($type_id,'%s','%s')";
    $sql_check  = "SELECT pub_id FROM pub WHERE uniquename='%s'";
  }
  // We are going to do an add or delete operation:
  if (!empty($add)) {
    $name = !empty($data['uniquename']) ? $data['uniquename'] : $type_name;
    $db_results = '';
    switch ($add) {
      case 'REPLACE':
        $check = db_fetch_array(db_query($sql_check, $name));
        if (!empty($check)) {
          db_query($sql_delete, $name);
        }
        db_query($sql_insert, $name, $name);
        $db_results = db_query($sql_select ." AND uniquename='$name'");
        break;

      case 'ADD':
        $check = db_fetch_array(db_query($sql_check, $name));
        if (empty($check)) {
          db_query($sql_insert, $name, $name);
        }
        $db_results = db_query($sql_select ." AND uniquename='$name'");
        break;

      case 'DELETE':
        $check = db_fetch_array(db_query($sql_check, $name));
        if (!empty($check)) {
          db_query($sql_delete, $name);
        }
        $check = db_fetch_array(db_query($sql_check, $name));
        if (!empty($check)) {
          gmod_dbsf_drupal_set_message(gmod_dbsf_t('Failed to delete publication %name. Perhaps a permissions error?', array('%name' => $name)), 'error');
          return FALSE;
        }
        return TRUE;
    }
  }
  else {
    // add limits only when we are not adding.
    if (!empty($data)) {
      foreach ($data as $key => $value) {
        $sql_select .= " AND $key='$value'";
      }
    }
    $db_results = db_query($sql_select .' ORDER by uniquename');
  }
  if (empty($db_results)) {
    return FALSE;
  }
  while ($row = db_fetch_array($db_results)) {
    if (!empty($name_as_key) && $name_as_key === 'BOTH') {
      $return_array[$row['uniquename']] = $row['uniquename'];
    }
    elseif (empty($name_as_key)) {
      $return_array[$row['pub_id']] = $row['uniquename'];
    }
    else {
      $return_array[$row['uniquename']] = $row['pub_id'];
    }
  }

  if (!empty($return_array)) {
    return $return_array;
  }
  else {
    return FALSE;
  }
}

/**
 * Clear all or part of $_SESSION
 *
 * For example, this is used in the genes4all_experiment module to empty the user
 * session variables.
 *
 * @param $var
 *   A string or a list array of $_SESSION parameter names(s) to empty.
 *   If no $var is provided, then the whole of $_SESSION is emptied
 *   (use with care)
 */
function gmod_dbsf_clear_session($var = NULL) {
  if (empty($var)) {
    $_SESSION = array();
  }
  else {
    if (is_array($var)) {
      foreach ($var as $element) {
        unset($_SESSION[$element]);
      }
    }
    else {
      unset($_SESSION[$var]);
    }
  }
  return TRUE;
}

/**
 * Create a Unique Identifier using SESSIONID, time and, optionally, a string
 *
 * Heavily used by the dbsf module to create unique identifiers. It is not
 * meant to be decoded.
 *
 * Uses the md5 algorithm to generate a hexadecimal unique identifier.
 * @see session_id()
 * @see time()
 * @see md5()
 *
 * @param $sessionid
 *   the session id to include in the calculation. If empty, it is retrieved.
 * @param $timestamp
 *   Unix timestamp (integer) to include in md5 calculation.
 *   If empty, it's retrieved.
 * @param $string
 *   Optionally, add a string to the md5 calculation. This allows you to
 *   generate multiple UIDs with the same timestamp.
 *
 * @return
 *   A 32 letter long hexadecimal string.
 *   e.g. d0bfa38422474be81a716e3dbe7ad21e
 */
function gmod_dbsf_create_uid($sessionid = NULL, $timestamp = NULL, $string = NULL) {
  if (empty($sessionid)) {
    $sessionid = session_id();
  }
  if (empty($timestamp)) {
    $timestamp = time();
  }
  //md5sum
  $uid = md5($sessionid . $timestamp . $string);
  return $uid;
}

/**
 * Get 1+ resource names/IDs by providing 1+ resource IDs/names
 *
 * @param $resource
 *   A string or list array of IDs or uniquename of resources to fetch
 * @param $name_as_key
 *   A boolean, if true then the key of the returned array is the uniquename.
 *
 * @return
 *   An associative array with the ID and uniquename of each resource
 *   The key is the ID unless $name_as_key is set.
 */
function gmod_dbsf_get_resource_name_id($resource, $name_as_key = FALSE) {
  if (empty($resource)) {
    return FALSE;
  }
  $return_array = array();
  $is_chado = gmod_dbsf_is_chado();

  foreach ((array)$resource as $r) {
    $sql_select = '';
    if ($is_chado === FALSE) {
      $sql_select = 'SELECT resource_id as id,uniquename FROM {gmod_dbsf_resource} as resource WHERE ';
    }
    else {
      $sql_select = 'SELECT resource_id as id,uniquename FROM resource WHERE ';
    }
    if (is_numeric($r)) {
      $sql_select .= 'resource_id=%d';
    }
    else {
      $sql_select .= "uniquename='%s'";
    }
    $res = db_fetch_array(db_query($sql_select, $r));
    if (!empty($name_as_key)) {
      $return_array[$res['uniquename']] = $res['id'];
    }
    else {
      $return_array[$res['id']] = $res['uniquename'];
    }
  }
}

/**
 * Get a list of resources, replace or add a new one
 *
 * @param $type_name
 *   Name of the cvterm which defines the resource type
 * @param $data
 *   (optional) An assoc. array to limit SELECT queries: the keys are used as
 *   column and values as the condition. Further, when adding/replacing,
 *   $data has to contain keys with 'uniquename' and 'dbxref_name'
 * @param $add
 *  Switch which can be FALSE/NULL, ADD, DELETE or REPLACE
 * @param $name_as_key
 *   A boolean. If TRUE the return array has uniquename as keys and
 *   resource_id as values. if ALL then all data is returned in associative array
 *
 * @return
 *   An associative array with resource_id as the keys and uniquename as values
 *    but see $name_as_key
 *   Or FALSE on failure.
 */
function gmod_dbsf_get_add_resource($type_name, $data = NULL, $add = FALSE, $name_as_key = FALSE) {
  if (empty($type_name)) {
    return FALSE;
  }
  $return_array = array();
  $type_id = gmod_dbsf_get_add_cv_withnames('resource_type', $type_name);
  if (empty($type_id)) {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('Could not add resource_type cvterm for %type_name', array('%type_name' => $type_name)), 'error');
    return FALSE;
  }
  $dbxref_name = !empty($data['dbxref_name']) ? $data['dbxref_name'] : 'local resource';
  $is_chado    = gmod_dbsf_is_chado();
  $sql_select  = '';
  $sql_delete  = '';
  $sql_insert1 = '';
  $sql_check   = '';
  $sql_insert2 = '';

  if ($is_chado === FALSE) {
    $sql_select  = "SELECT * FROM {gmod_dbsf_resource} as resource WHERE type_id=%d";
    $sql_delete  = "DELETE FROM {gmod_dbsf_resource} WHERE type_id=%d AND uniquename='%s' ";
    $sql_insert1 = "INSERT into {gmod_dbsf_resource} (type_id,uniquename,dbxref_id) VALUES (%d,'%s',%d)";
    $sql_check   = "SELECT resource_id FROM {gmod_dbsf_resource} as resource WHERE uniquename='%s'";
    $sql_insert2 = "INSERT into {gmod_dbsf_resource} (type_id,uniquename,dbxref_id,organism_id) VALUES (%d,'%s',%d,%d)";
  }
  else {
    $sql_select  = "SELECT * FROM resource WHERE type_id=%d";
    $sql_delete  = "DELETE FROM resource WHERE type_id=%d AND uniquename='%s' ";
    $sql_insert1 = "INSERT into resource (type_id,uniquename,dbxref_id) VALUES (%d,'%s',%d)";
    $sql_check   = "SELECT resource_id FROM resource WHERE uniquename='%s'";
    $sql_insert2 = "INSERT into resource (type_id,uniquename,dbxref_id,organism_id) VALUES (%d,'%s',%d,%d)";
  }
  // We are going to do an add or delete operation:
  if (!empty($add)) {
    $dbxref_id = gmod_dbsf_get_add_dbxref_withnames('local resource', $dbxref_name);
    if (empty($dbxref_id) && $add !== 'DELETE') {
      gmod_dbsf_drupal_set_message(gmod_dbsf_t('Could not add resource because could not get dbxref id for %d', array('%d' => $data['dbxref_name'])), 'error');
      return FALSE;
    }
    $name = !empty($data['uniquename']) ? $data['uniquename'] : $type_name;
    if (empty($name)) {
      gmod_dbsf_drupal_set_message(gmod_dbsf_t('Did not %add requested resource because name/id was missing or not given correctly', array('%add' => $add)), 'error');
      return FALSE;
    }
    $sql_insert = $sql_insert1;
    if (!empty($data['organism_id'])) {
      if (!is_numeric($data['organism_id'])) {
        //security
        gmod_dbsf_drupal_set_message(gmod_dbsf_t('Organism ID is not correct.'), 'error');
        return FALSE;
      }
      $sql_insert = $sql_insert2;
    }
    switch ($add) {
      case 'REPLACE':
        $check = db_fetch_array(db_query($sql_check, $name));
        if (!empty($check)) {
          db_query($sql_delete, $type_id, $name);
        }
        if (!empty($data['organism_id'])) {
          db_query($sql_insert, $type_id, $name, $dbxref_id, $data['organism_id']);
        }
        else {
          db_query($sql_insert, $type_id, $name, $dbxref_id);
        }
        break;

      case 'ADD':
        $check = db_fetch_array(db_query($sql_check, $name));
        if (empty($check)) {
          if (!empty($data['organism_id'])) {
            db_query($sql_insert, $type_id, $name, $dbxref_id, $data['organism_id']);
          }
          else {
            db_query($sql_insert, $type_id, $name, $dbxref_id);
          }
        }
        break;

      case 'DELETE':
        $check = db_fetch_array(db_query($sql_check, $name));
        if (!empty($check)) {
          db_query($sql_delete, $type_id, $name);
        }
        $check = db_fetch_array(db_query($sql_check, $name));
        if (empty($check)) {
          return TRUE;
        }
        else {
          gmod_dbsf_drupal_set_message(gmod_dbsf_t('Failed to delete %name.', array('%name' => $name)), 'error');
          return FALSE;
        }
    }
  }
  else {
    // add limits only when we are not adding.
    if (!empty($data)) {
      foreach ($data as $key => $value) {
        $sql_select .= " AND $key='$value'";
      }
    }
  }
  $db_results = db_query($sql_select .' ORDER by uniquename', $type_id);
  while ($row = db_fetch_array($db_results)) {
    if (empty($name_as_key)) {
      $return_array[$row['resource_id']] = $row['uniquename'];
    }
    elseif ($name_as_key === 'BOTH') {
      $return_array[$row['uniquename']] = $row['uniquename'];
    }
    elseif ($name_as_key === 'ALL') {
      $return_array[$row['resource_id']] = $row;
    }
    else {
      $return_array[$row['uniquename']] = $row['resource_id'];
    }
  }

  if (!empty($return_array)) {
    return $return_array;
  }
  else {
    return FALSE;
  }
}

/**
 * Get cvterms and properties for a resource
 *
 * @param $resource
 *   ID or name of resource to get cvterms and properties for.
 *
 * @return
 *   An associative array WHERE the primary key is 'cvterm' and 'prop' for
 *   cvterms and properties respectively.
 *   'cvterm' is has cvterm.names in a list array foreach cv_name.
 *   'prop' does likewise for values of each cvterm.name
 */
function gmod_dbsf_get_resource_cvterm_and_prop($resource) {
  $return_array = array();
  if (empty($resource)) {
    return FALSE;
  }
  $cvterm_select = '';
  $prop_select   = '';
  $is_chado      = gmod_dbsf_is_chado();
  if ($is_chado === FALSE) {
    $cvterm_select = 'SELECT cvterm.name as cvterm_name,cv.name as cv_name FROM {gmod_dbsf_resource_cvterm} as r ' . ' JOIN {gmod_dbsf_cvterm} as cvterm ON r.cvterm_id=cvterm.cvterm_id' . ' JOIN {gmod_dbsf_cv} as cv ON cv.cv_id=cvterm.cv_id ';
    $prop_select = 'SELECT cvterm.name as cvterm_name,r.value,r.rank FROM {gmod_dbsf_resourceprop} as r ' . ' JOIN {gmod_dbsf_cvterm} as cvterm ON r.type_id=cvterm.cvterm_id ';
  }
  else {
    $cvterm_select = 'SELECT cvterm.name as cvterm_name,cv.name as cv_name FROM resource_cvterm as r ' . ' JOIN cvterm ON r.cvterm_id=cvterm.cvterm_id' . ' JOIN cv ON cv.cv_id=cvterm.cv_id ';
    $prop_select = 'SELECT cvterm.name as cvterm_name,r.value,r.rank FROM resourceprop as r ' . ' JOIN cvterm ON r.type_id=cvterm.cvterm_id ';
  }
  if (is_numeric($resource)) {
    $cvterm_select .= ' WHERE r.resource_id=%d ';
    $prop_select .= ' WHERE r.resource_id=%d ';
  }
  else {
    if ($is_chado === FALSE) {
      $cvterm_select .= " WHERE r.resource_id=(SELECT resource_id FROM {gmod_dbsf_resource} as resource WHERE uniquename='%s')";
      $prop_select .= " WHERE r.resource_id=(SELECT resource_id FROM {gmod_dbsf_resource} as resource WHERE uniquename='%s')";
    }
    else {
      $cvterm_select .= " WHERE r.resource_id=(SELECT resource_id FROM resource WHERE uniquename='%s')";
      $prop_select .= " WHERE r.resource_id=(SELECT resource_id FROM resource WHERE uniquename='%s')";
    }
  }

  $prop_select .= ' ORDER by r.rank';
  $cv_res = db_query($cvterm_select, $resource);
  while ($row = db_fetch_array($cv_res)) {
    $return_array['cvterm'][$row['cv_name']][] = $row['cvterm_name'];
  }
  $prop_res = db_query($prop_select, $resource);
  while ($row = db_fetch_array($prop_res)) {
    $return_array['prop'][$row['cvterm_name']][$row['rank']] = $row['value'];
  }
  if (!empty($return_array)) {
    return $return_array;
  }
  else {
    return FALSE;
  }
}

/**
 * Rename a resource
 *
 * @param $old_name
 *   Resource's current uniquename
 * @param $new_name
 *   New uniquename to set for $old_name resource
 *
 * @return
 *   TRUE on success and FALSE on failure. On failure it also sets a message.
 */
function gmod_dbsf_rename_resource($old_name, $new_name) {
  if (empty($old_name) || empty($new_name)) {
    return FALSE;
  }
  $is_chado   = gmod_dbsf_is_chado();
  $select_sql = '';
  $update_sql = '';
  if ($is_chado === FALSE) {
    $select_sql = "SELECT resource_id FROM {gmod_dbsf_resource} as resource WHERE uniquename='%s'";
    $update_sql = "UPDATE {gmod_dbsf_resource} SET uniquename='%s' WHERE uniquename='%s'";
  }
  else {
    $select_sql = "SELECT resource_id FROM resource WHERE uniquename='%s'";
    $update_sql = "UPDATE resource SET uniquename='%s' WHERE uniquename='%s'";
  }
  $res = db_fetch_array(db_query($select_sql, $old_name));
  if (empty($res['resource_id'])) {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('Failed to rename as I cannot find %old_name', array('%old_name' => $old_name)), 'error');
    return FALSE;
  }
  db_query($update_sql, $new_name, $old_name);
  $res = db_fetch_array(db_query($select_sql, $new_name));
  if (empty($res['resource_id'])) {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('For some reason, I failed to rename %old_name to %new_name', array('%old_name' => $old_name, '%new_name' => $new_name)), 'error');
    return FALSE;
  }
  return TRUE;
}

/**
 * Link two resources with a relationship
 *
 * @see gmod_dbsf_link_unlink_features
 *
 * @param $subject
 *   The resource_ID or uniquename of the subject of the relationship
 * @param $rel
 *   The name of a relationship such as 'part_of' or 'uses'
 * @param $object
 *   The resource_ID or uniquename object of the relationship
 * @param $replace
 *   Whether to fail if an existing relationship exists (FALSE), replace
 *   it (REPLACE) or simply delete it ('DELETE'). If $object is NULL and $replace
 *   is DELETE then all relationships $rel for $subject are removed.
 *
 * @return
 *   TRUE on success.
 */
function gmod_dbsf_link_unlink_resources($subject, $rel, $object = NULL, $replace = FALSE) {
  if (empty($subject) || empty($rel)) {
    return FALSE;
  }
  $type_id = gmod_dbsf_get_add_cv_withnames('relationship', $rel);
  if (empty($type_id)) {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('Could not add cvterm for %rel', array('%rel' => $rel)), 'error');
    return FALSE;
  }
  $is_chado     = gmod_dbsf_is_chado();
  $object_grab  = '';
  $subject_grab = '';
  if ($is_chado === FALSE) {
    $subject_grab = "(SELECT resource_id FROM {gmod_dbsf_resource} as resource WHERE uniquename='%s')";
  }
  else {
    $subject_grab = "(SELECT resource_id FROM resource WHERE uniquename='%s')";
  }
  if (!empty($object)) {
    if ($is_chado === FALSE) {
      $object_grab = "(SELECT resource_id FROM {gmod_dbsf_resource} WHERE uniquename='%s')";
    }
    else {
      $object_grab = "(SELECT resource_id FROM resource WHERE uniquename='%s')";
    }
  }
  if (is_numeric($subject)) {
    $subject_grab = '%d';
  }
  if (!empty($object) && is_numeric($object)) {
    $object_grab = '%d';
  }

  if (empty($object)) {
    if ($replace === 'DELETE') {
      $sql_delete_all = '';
      if ($is_chado === FALSE) {
        $sql_delete_all = 'DELETE FROM {gmod_dbsf_resource_resource} WHERE subject_id='. $subject_grab ."and type_id=%d";
      }
      else {
        $sql_delete_all = 'DELETE FROM resource_resource WHERE subject_id='. $subject_grab ."and type_id=%d";
      }
      db_query($sql_delete_all, $subject, $type_id);
      return TRUE;
    }
    return FALSE;
  }
  $sql_select     = '';
  $sql_delete_all = '';
  $sql_check      = '';
  $sql_insert     = '';
  $sql_delete     = '';
  if ($is_chado === FALSE) {
    $sql_select     = 'SELECT resource_id as id FROM {gmod_dbsf_resource} as resource WHERE resource_id IN'. " (SELECT object_id FROM {gmod_dbsf_resource_resource} as resource_resource WHERE subject_id=$subject_grab)". " AND type_id=(SELECT type_id FROM {gmod_dbsf_resource} as resource WHERE resource_id=$object_grab) ";
    $sql_delete_all = 'DELETE FROM {gmod_dbsf_resource_resource} WHERE subject_id='. $subject_grab .' AND object_id IN '. "(SELECT resource_id FROM {gmod_dbsf_resource} as resource WHERE type_id=(SELECT type_id FROM {gmod_dbsf_resource} as resource WHERE resource_id=$object_grab))";
    $sql_check      = 'SELECT resource_resource_id as id FROM {gmod_dbsf_resource_resource} as resource_resource WHERE subject_id='. $subject_grab .' AND object_id='. $object_grab;
    $sql_insert     = 'INSERT INTO {gmod_dbsf_resource_resource} (subject_id,object_id,type_id) VALUES ('. $subject_grab .','. $object_grab .',%d)';
    $sql_delete     = 'DELETE FROM {gmod_dbsf_resource_resource} WHERE subject_id='. $subject_grab .' AND object_id='. $object_grab;
  }
  else {
    $sql_select     = 'SELECT resource_id as id FROM resource WHERE resource_id IN'. " (SELECT object_id FROM resource_resource WHERE subject_id=$subject_grab)". " AND type_id=(SELECT type_id FROM resource WHERE resource_id=$object_grab) ";
    $sql_delete_all = 'DELETE FROM resource_resource WHERE subject_id='. $subject_grab .' AND object_id IN '. "(SELECT resource_id FROM resource WHERE type_id=(SELECT type_id FROM resource WHERE resource_id=$object_grab))";
    $sql_check      = 'SELECT resource_resource_id as id FROM resource_resource WHERE subject_id='. $subject_grab .' AND object_id='. $object_grab;
    $sql_insert     = 'INSERT INTO resource_resource (subject_id,object_id,type_id) VALUES ('. $subject_grab .','. $object_grab .',%d)';
    $sql_delete     = 'DELETE FROM resource_resource WHERE subject_id='. $subject_grab .' AND object_id='. $object_grab;
  }
  $res = db_fetch_array(db_query($sql_check, $subject, $object));
  switch ($replace) {
    case FALSE:
      if (empty($res['id'])) {
        db_query($sql_insert, $subject, $object, $type_id);
        //dvm("Inserted $subject $rel $object");
        return TRUE;
      }
      else {
        //dvm("A relationship exists already for subject $subject and object $object.");
        return TRUE;
      }
      break;

    case 'DELETE':
      if (empty($res['id'])) {
        return TRUE;
      }
      else {
        db_query($sql_delete, $subject, $object);
        $res = db_fetch_array(db_query($sql_check, $subject, $object));
        if (empty($res['id'])) {
          //dvm("Deleted previous relationship $subject $object.");
          return TRUE;
        }
        else {
          //dvm("Failed to delete previous relationship for $subject $object.");
          return FALSE;
        }
      }
      break;

    case 'REPLACE':
      // all objects of same type
      $res_select = db_fetch_array(db_query($sql_select, $subject, $object));
      // if there is one
      if (!empty($res_select['id'])) {
        // and it's not the one we want to add
        if (empty($res['id'])) {
          //delete old one
          db_query($sql_delete_all, $subject, $object);
          $res = db_fetch_array(db_query($sql_check, $subject, $object));
          // if it has been deleted, insert
          if (empty($res['id'])) {
            db_query($sql_insert, $subject, $object, $type_id);
            return TRUE;
          }
          else {
            //dvm("Failed to delete previous relationship for $subject $object.");
            return FALSE;
          }
        }
        else {
          // no reason to do anything.
          return FALSE;
        }
      }
      elseif (empty($res['id'])) {
        //nothing in currently, so insert
        db_query($sql_insert, $subject, $object, $type_id);
        //dvm("Inserted $subject $rel $object");
        return TRUE;
      }
      break;
  }
}

/**
 * Get all object resources stored in the resource_resource table
 *
 * @param $resource id
 *   ID or uniquename of subject resource
 * @param $relationship_name
 *   Optionally delimit by relationship type by providing the type name
 * @param $name_as_key
 *   A boolean, if TRUE then the return array has uniquename as key
 * @param $limit
 *   A string. Optionally pass a string to add as LIMIT to the query.
 *
 * @return
 *  A 2D associative array with primary key the object_id and secondary
 *  the column names object_type,object_name for each object resource
 */
function gmod_dbsf_get_linked_resources($resource, $relationship_name = NULL, $name_as_key = FALSE, $limit = NULL) {
  $return_array = array();
  if (empty($resource)) {
    return FALSE;
  }
  $is_chado = gmod_dbsf_is_chado();
  $sql_select = '';
  if ($is_chado === FALSE) {
    $sql_select = 'SELECT rr.object_id,rocvterm.name as object_type,ro.uniquename as object_name ' . 'FROM {gmod_dbsf_resource_resource} as rr ' . ' JOIN {gmod_dbsf_resource} as ro ON ro.resource_id=rr.object_id ' . ' JOIN {gmod_dbsf_cvterm} as rocvterm ON rocvterm.cvterm_id=ro.type_id ';
  }
  else {
    $sql_select = 'SELECT rr.object_id,rocvterm.name as object_type,ro.uniquename as object_name ' . 'FROM resource_resource as rr ' . ' JOIN resource as ro ON ro.resource_id=rr.object_id ' . ' JOIN cvterm as rocvterm ON rocvterm.cvterm_id=ro.type_id ';
  }
  if (is_numeric($resource)) {
    $sql_select .= 'WHERE rr.subject_id=%d';
  }
  else {
    if ($is_chado === FALSE) {
      $sql_select .= "WHERE rr.subject_id=(SELECT resource_id FROM {gmod_dbsf_resource} as resource WHERE uniquename='%s')";
    }
    else {
      $sql_select .= "WHERE rr.subject_id=(SELECT resource_id FROM resource WHERE uniquename='%s')";
    }
  }
  if (!empty($relationship_name)) {
    $type_id = gmod_dbsf_get_add_cv_withnames('relationship', $relationship_name);
    $sql_select .= " AND rr.type_id=$type_id ";
  }
  if (!empty($limit)) {
    $sql_select .= " AND $limit ";
  }
  $res = db_query($sql_select, $resource);
  while ($row = db_fetch_array($res)) {
    if (!empty($name_as_key)) {
      $return_array[$row['object_name']] = array(
        'type_name' => $row['object_type'],
        'uniquename' => $row['object_name'],
        'id' => $row['object_id'],
      );
    }
    else {
      $return_array[$row['object_id']] = array(
        'type_name' => $row['object_type'],
        'uniquename' => $row['object_name'],
        'id' => $row['object_id'],
      );
    }
  }

  if (!empty($return_array)) {
    return $return_array;
  }
  else {
    return FALSE;
  }
}

/**
 * Link two resources with a relationship
 *
 * A bit different FROM the _link_unlink_resources function.
 * @see gmod_dbsf_link_unlink_resources
 * This function accepts a single variable as an associative array with the
 * following keys: 'start', 'end' for start and end respectively;
 * 'phase' and 'strand' as used by GFF3 (defaults to NULL and + respectively)
 * 'feature' for the subject feature's ID as internal numeric or uniquename
 * and likewise with 'parent' for the parental ID.
 * Further, 'delete' actually deletes a relationship instead of adding it.
 *
 *
 * @return
 *   The function uses the featureloc table to attach the 'feature' to the 'parent'
 *   using the 'start' and 'end' coordinates provided.
 *   TRUE on success, FALSE on failure.
 */
function gmod_dbsf_link_unlink_features($data) {
  // count FROM 1
  $start   = $data['start'];
  $end     = $data['end'];
  $feature = $data['feature'];
  $parent  = $data['parent'];
  $phase   = !empty($data['phase']) ? $data['phase'] : '';
  $strand  = !empty($data['strand']) ? $data['strand'] : '+';
  $delete  = $data['delete'];
  $error   = 0;
  if (empty($feature) || empty($parent)) {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('Not enough data to store link between two features.'), 'error');
    return FALSE;
  }
  $feature_id = is_numeric($feature) ? $feature : 0;
  $parent_id = is_numeric($parent) ? $parent : 0;
  if (empty($feature_id)) {
    $res = gmod_dbsf_get_feature_name_id($feature, TRUE);
    $feature_id = $res[$feature];
  }
  if (empty($parent_id)) {
    $res = gmod_dbsf_get_feature_name_id($parent, TRUE);
    $parent_id = $res[$parent];
  }
  if (empty($feature_id) || empty($parent_id)) {
    gmod_dbsf_drupal_set_message(gmod_dbsf_t('Failed to get IDs for %feature AND its parent %parent.', array('%feature' => $feature, '%parent' => $parent)), 'error');
    return FALSE;
  }
  $is_chado = gmod_dbsf_is_chado();
  $sql_parent_check = '';
  $sql_parent_get_next_rank = '';
  $sql_parent_insert = '';
  $sql_parent_delete = '';
  if ($is_chado === FALSE) {
    $sql_parent_check = "SELECT featureloc_id FROM {gmod_dbsf_featureloc} as featureloc WHERE feature_id=%d AND srcfeature_id=%d";
    $sql_parent_get_next_rank = "SELECT max(rank)+1 as next_rank FROM {gmod_dbsf_featureloc} as featureloc WHERE feature_id=%d";
    $sql_parent_insert = "INSERT INTO {gmod_dbsf_featureloc} (feature_id,srcfeature_id,fmin,fmax,phase,strand,rank) VALUES " . "(%d,%d,%d,%d,%d,%d,%d)";
    $sql_parent_delete = "DELETE FROM {gmod_dbsf_featureloc} WHERE feature_id=%d AND srcfeature_id=%d";
  }
  else {
    $sql_parent_check = "SELECT featureloc_id FROM featureloc WHERE feature_id=%d AND srcfeature_id=%d";
    $sql_parent_get_next_rank = "SELECT max(rank)+1 as next_rank FROM featureloc WHERE feature_id=%d";
    $sql_parent_insert = "INSERT INTO featureloc (feature_id,srcfeature_id,fmin,fmax,phase,strand,rank) VALUES " . "(%d,%d,%d,%d,%d,%d,%d)";
    $sql_parent_delete = "DELETE FROM featureloc WHERE feature_id=%d AND srcfeature_id=%d";
  }
  $daughter_check = db_fetch_array(db_query($sql_parent_check, $feature_id, $parent_id));
  if (empty($daughter_check)) {
    //fmin is interbase coordinate starting FROM 0, so -1
    $rank      = db_fetch_array(db_query($sql_parent_get_next_rank, $feature_id));
    $next_rank = !empty($rank['next_rank']) ? $rank['next_rank'] : 0;
    $fmin      = !empty($start) ? $start - 1 : 0;
    $fmax      = !empty($end) ? $end : 0;
    db_query($sql_parent_insert, $feature_id, $parent_id, $fmin, $fmax, $phase, $strand, $next_rank);
    $daughter_check = db_fetch_array(db_query($sql_parent_check, $feature_id, $parent_id));
    if (empty($daughter_check)) {
      gmod_dbsf_drupal_set_message(gmod_dbsf_t('Failed to link your feature %feature with its parent %parent. Perhaps you have not requested the parent to be added or perhaps a permissions error, contact the administrator.', array('%feature' => $feature, '%parent' => $parent)), 'error');
      $error = 1;
    }
  }
  else {
    if (!empty($delete)) {
      db_query($sql_parent_delete, $feature_id, $parent_id);
      $daughter_check = db_fetch_array(db_query($sql_parent_check, $feature_id, $parent_id));
      if (!empty($daughter_check)) {
        gmod_dbsf_drupal_set_message(gmod_dbsf_t('Failed to unlink your feature %feature FROM its parent %parent. Perhaps you have not requested the parent to be added or perhaps a permissions error, contact the administrator.', array('%feature' => $feature, '%parent' => $parent)), 'error');
        $error = 1;
      }
    }
  }
  if (!empty($error)) {
    return FALSE;
  }
  return TRUE;
}


/**
 * Tell me what is the id and uniquename for a feature
 *
 * If I give a name or id, it will return an array with id and key
 *
 * @param $feature
 *  A string or integer relating to ID or uniquename of feature
 *
 *  @return
 *   Array with keys 'id' and 'uniquename'
 */
function gmod_dbsf_decypher_feature($feature){
  if (empty($feature)) {return FALSE;}
  $return_array = array();
  $data = gmod_dbsf_get_feature_name_id($feature);
  if (empty($data)){return;}
  foreach ($data as $id=>$name){
    $return_array[]=array('id'=>$id,'uniquename'=>$name);
  }
  if (!empty($return_array[1])){
    return $return_array;
  }else{
    return $return_array[0];
  }
}

/**
 * Get 1+ feature names/IDs by providing 1+ feature IDs/names
 *
 * TODO Convert to gmod_dbsf_decypher_feature
 * @param $feature
 *   A string or list array of IDs or uniquename of features to fetch
 * @param $name_as_key
 *   A boolean, if true then the key of the returned array is the uniquename.
 *
 * @return
 *   An associative array with the 'id' and 'uniquename' of each feature
 *   The key is the ID unless $name_as_key is set.
 */
function gmod_dbsf_get_feature_name_id($feature=NULL, $name_as_key = FALSE) {
  if (empty($feature)) {
    return FALSE;
  }
  $return_array = array();
  $is_chado = gmod_dbsf_is_chado();

  foreach ((array)$feature as $r) {
    $sql_select = '';
    if ($is_chado === FALSE) {
      $sql_select = 'SELECT feature_id as id,uniquename FROM {gmod_dbsf_feature} as feature WHERE ';
    }
    else {
      $sql_select = 'SELECT feature_id as id,uniquename FROM feature WHERE ';
    }
    if (is_numeric($r)) {
      $sql_select .= 'feature_id=%d';
    }
    else {
      $sql_select .= "uniquename='%s'";
    }
    $res = db_fetch_array(db_query($sql_select, $r));
    if ($is_chado !== FALSE) {
      $access = gmod_dbsf_chadoapi_check_restriction('select','feature',$res['id'],FALSE);
      if (empty($access)){
        return FALSE;
      }
    }
    if (empty($name_as_key)) {
      $return_array[$res['id']] = $res['uniquename'];
    }
    elseif ($name_as_key == 'STRING') {
      $return_array = $res['uniquename'];
    }
    else {
      $return_array[$res['uniquename']] = $res['id'];
    }
  }
  return $return_array;
}

/**
 * Get a list of features, replace or delete one
 *
 * This is a general function name. Does not add new features.
 * @see gmod_dbsf_store_feature()
 *
 * @param $type_name
 *   Name of the cvterm which defines the feature type
 * @param $data
 *   (optional) An assoc. array to limit SELECT queries: the keys are used as
 *   column and values as the condition. Further, when adding/replacing,
 *   $data has to contain keys with 'uniquename' and 'dbxref_name'
 * @param $change
 *  Switch which can be FALSE/NULL, ADD, DELETE or REPLACE
 * @param $name_as_key
 *   A boolean. If TRUE the return array has uniquename as keys and
 *   feature_id as values.
 *
 * @return
 *   An associative array with feature_id as the keys and uniquename as values.
 *   Or FALSE on failure.
 */
function gmod_dbsf_get_change_feature($type_name = NULL, $data = NULL, $change = FALSE, $name_as_key = FALSE) {
  $return_array = array();
  $type_id      = 0;
  $is_chado     = gmod_dbsf_is_chado();
  $sql_select   = '';
  if (!empty($type_name)) {
    if (is_numeric($type_name)) {
      $type_check = '';
      if ($is_chado === FALSE) {
        $type_check = db_fetch_array(db_query('SELECT cvterm_id as id FROM {gmod_dbsf_cvterm} WHERE cvterm_id=%d', $type_name));
      }
      else {
        $type_check = db_fetch_array(db_query('SELECT cvterm_id as id FROM cvterm WHERE cvterm_id=%d', $type_name));
      }
      if (!empty($type_check['id'])) {
        $type_id = $type_name;
      }
    }
    if (empty($type_id)) {
      $type_id = gmod_dbsf_get_add_cv_withnames('sequence', $type_name);
    }
    if (empty($type_id)) {
      drupal_set_message(t('Could not add cvterm for %type_name', array('%type_name' => $type_name)), 'error');
      return FALSE;
    }
    if ($is_chado === FALSE) {
      $sql_select = "SELECT feature_id,uniquename FROM {gmod_dbsf_feature} f WHERE type_id=%d";
    }
    else {
      $sql_select = "SELECT feature_id,uniquename FROM feature f WHERE type_id=%d";
    }
  }
  else {
    if (!empty($data) || !empty($change)) {
      return FALSE;
    }
    if ($is_chado === FALSE) {
      $sql_select = "SELECT feature_id,uniquename,cvterm.name as type_name FROM {gmod_dbsf_feature} f JOIN cvterm ON cvterm_id=type_id";
    }
    else {
      $sql_select = "SELECT feature_id,uniquename,cvterm.name as type_name FROM feature f JOIN cvterm ON cvterm_id=type_id";
    }
  }

  // We are going to do an add or delete operation:
  if (!empty($change)) {
    $dbxref_id = gmod_dbsf_get_add_dbxref_withnames('local feature', $data['dbxref_name']);
    if (empty($dbxref_id) && $change !== 'DELETE') {
      drupal_set_message(t('Could not add feature because could not get dbxref id for %d', array('%d' => $data['dbxref_name'])), 'error');
      return FALSE;
    }
    $name = $data['uniquename'];
    if (empty($name)) {
      drupal_set_message(t('Did not %change requested feature because name/id was missing or not given correctly', array('%change' => $change)), 'error');
      return FALSE;
    }
    $sql_delete = '';
    $sql_check = '';
    if ($is_chado === FALSE) {
      $sql_delete = "DELETE FROM {gmod_dbsf_feature} WHERE type_id=%d AND uniquename='%s'";
      $sql_check = "SELECT feature_id FROM {gmod_dbsf_feature} as f WHERE uniquename='%s'";
    }
    else {
      $sql_delete = "DELETE FROM feature WHERE type_id=%d AND uniquename='%s'";
      $sql_check = "SELECT feature_id FROM feature as f WHERE uniquename='%s'";
    }
    switch ($change) {
      case 'ADD':
        $check = db_fetch_array(db_query($sql_check, $name));
        if (!empty($check)) {
          gmod_dbsf_store_feature($data);
        }
      case 'REPLACE':
        $check = db_fetch_array(db_query($sql_check, $name));
        if (!empty($check)) {
          db_query($sql_delete, $type_id, $name);
        }
        $check = db_fetch_array(db_query($sql_check, $name));
        if (!empty($check)) {
          gmod_dbsf_store_feature($data);
        }
        break;

      case 'DELETE':
        $check = db_fetch_array(db_query($sql_check, $name));
        if (!empty($check)) {
          db_query($sql_delete, $type_id, $name);
        }
        return TRUE;
    }
  }
  else {
    // add limits only when we are not adding.
    if (!empty($data)) {
      foreach ($data as $key => $value) {
        $sql_select .= " AND $key='$value'";
      }
    }
  }
  if (!empty($type_id)) {
    $db_results = db_query($sql_select .' ORDER by uniquename', $type_id);
    while ($row = db_fetch_array($db_results)) {
      if (!empty($name_as_key) && $name_as_key === 'BOTH') {
        $return_array[$row['uniquename']] = $row['uniquename'];
      }
      elseif (empty($name_as_key)) {
        $return_array[$row['feature_id']] = $row['uniquename'];
      }
      else {
        $return_array[$row['uniquename']] = $row['feature_id'];
      }
    }
  }
  else {
    $db_results = db_query($sql_select .' ORDER by type_name,uniquename');
    while ($row = db_fetch_array($db_results)) {
      if (!empty($name_as_key) && $name_as_key === 'BOTH') {
        $return_array[$row['type_name']][$row['uniquename']] = $row['uniquename'];
      }
      elseif (empty($name_as_key)) {
        $return_array[$row['type_name']][$row['feature_id']] = $row['uniquename'];
      }
      else {
        $return_array[$row['type_name']][$row['uniquename']] = $row['feature_id'];
      }
    }
  }
  if (!empty($return_array)) {
    return $return_array;
  }
  else {
    return FALSE;
  }
}

/**
 * Get all feature data regarding a feature and the uniquenames of its parents
 *
 * This functions on both Drupal and Chado
 *
 * @param $feature
 * The feature_id or uniquename
 *
 * @return associative array
 * with keys the columns of the feature table (and also type_name for the cvterm.name of type_id)
 * also the 'parent' key is the for a list of the uniquename(s) of the parent(s) according to featureloc.
 * If there is only one parent, then not a list but a string is the value of 'parent'
 */
function gmod_dbsf_get_feature_data($feature) {
  $return_array = array();
  if (empty($feature)) {
    return FALSE;
  }

  $is_chado = gmod_dbsf_is_chado();
  //$parent_data['parent_id'],$parent_data['start']-1,$parent_data['end'],$parent_data['phase'],$parent_data['strand']);
  //better to get name of parent in case parent is to be transfered between databases too.
  if ($is_chado === FALSE) {
    $select_sql = "SELECT f.*,cvterm.name as type_name FROM {gmod_dbsf_feature} as f JOIN {gmod_dbsf_cvterm} cvterm ON cvterm.cvterm_id=f.type_id";
    $select_parents = "SELECT f.uniquename as parent_name,fmin+1 as start,fmax as end,phase,strand FROM " . " {gmod_dbsf_featureloc} as fl JOIN {gmod_dbsf_feature} as f ON f.feature_id=fl.srcfeature_id";
  }
  else {
    $select_sql = "SELECT f.*,cvterm.name as type_name FROM feature as f JOIN cvterm cvterm ON cvterm.cvterm_id=f.type_id";
    $select_parents = "SELECT f.uniquename as parent_name,fmin+1 as start,fmax as end,phase,strand FROM " . " featureloc as fl JOIN feature as f ON f.feature_id=fl.srcfeature_id";
  }
  if (is_numeric($feature)) {
    $select_sql .= ' WHERE f.feature_id=%d ';
    $select_parents .= ' WHERE fl.feature_id=%d ';
  }
  else {
    if ($is_chado === FALSE) {
      $select_sql .= " WHERE f.feature_id=(SELECT feature_id FROM {gmod_dbsf_feature} as feature WHERE uniquename='%s')";
      $select_parents .= " WHERE fl.feature_id=(SELECT feature_id FROM {gmod_dbsf_feature} as feature WHERE uniquename='%s')";
    }
    else {
      $select_sql .= " WHERE f.feature_id=(SELECT feature_id FROM feature as feature WHERE uniquename='%s')";
      $select_parents .= " WHERE fl.feature_id=(SELECT feature_id FROM feature as feature WHERE uniquename='%s')";
    }
  }
  $data = db_fetch_array(db_query($select_sql, $feature));
  if ($is_chado !== FALSE) {
    $access = gmod_dbsf_chadoapi_check_restriction('select','feature',$data['feature_id'],FALSE);
    if (empty($access)){
      return FALSE;
    }
  }

  if (!empty($data)) {
    while ($parent_data = db_fetch_array(db_query($select_parents, $feature))) {
      $data['parent'][] = $parent_data['parent_name'];
    }
    if (!empty($data['parent']) && count($data['parent']) == 1) {
      $s = implode('', $data['parent']);
      $data['parent'] = $s;
    }
    return $data;
  }
  return FALSE;
}

/**
 * Get feature metadata (organism and library)
 *
 * @param $feature
 * The feature_id or uniquename
 *
 * @return associative array
 * Associative array indexed with the feature_id and keys the feature uniquename,
 * library_id, library_name, organism_id,organism_genus and organism_species
 *
 */
function gmod_dbsf_get_feature_metadata($feature){
  $return_array = array();
  if (empty($feature)) {return FALSE;}
  $feature_array = gmod_dbsf_get_feature_name_id($feature);
  if (empty($feature_array)){return;}
  $organism_sql = 'SELECT organism_id as id,genus,species from {organism} WHERE organism_id=('
  .'SELECT organism_id from {feature} where feature_id=%d'
  .')';
  $library_sql = 'SELECT library_id as id,uniquename from {library} WHERE library_id=('
  .'SELECT library_id from {library_feature} where feature_id=%d'
  .')';
  foreach ($feature_array as $id=>$name){
    $return_array[$id]['uniquename']=$name;
    $org_res = db_fetch_array(db_query($organism_sql,$id));
    if (!empty($org_res)){
      $return_array[$id]=array(
      'organism_id'=> $org_res['id']
      ,'organism_genus'=> $org_res['genus']
      ,'organism_species'=> $org_res['species']
      );
    }
    $lib_res = db_fetch_array(db_query($library_sql,$id));
    if (!empty($lib_res)){
      $return_array[$id]=array('library_id'=> $lib_res['id'],'library_name'=> $lib_res['name']);
    }
  }
  return $return_array;
}

function gmod_dbsf_decypher_cvterm($cvterm,$cv=NULL){
  if (empty($cvterm)){return;}
  $res = '';
  $sql = '';
  $is_chado      = gmod_dbsf_is_chado();
  if (is_numeric($cvterm) && empty($cv)){
    if ($is_chado === FALSE) {
      $sql = "SELECT name as a from {gmod_dbsf_cvterm} where cvterm_id=%d";
    }else{
      $sql = "SELECT name as a from {cvterm} where cvterm_id=%d";
    }
    $res=db_fetch_array(db_query($sql,$cvterm));

  }else{
    if (empty($cv)){
      return FALSE;
    }

    if (is_numeric($cv)){
        if ($is_chado === FALSE) {
            $sql = "SELECT cvterm_id as a  from {gmod_dbsf_cvterm} where name ='%s' AND cv_id=%d";
        }else{
            $sql = "SELECT cvterm_id as a from {cvterm} where name ='%s' AND cv_id=%d";
        }
    }else{
        if ($is_chado === FALSE) {
            $sql = "SELECT cvterm_id as a  from {gmod_dbsf_cvterm} where name ='%s' AND cv_id=(SELECT cv_id from {gmod_dbsf_cv} WHERE name='%s')";
        }else{
            $sql = "SELECT cvterm_id as a from {cvterm} where name ='%s' AND cv_id=(SELECT cv_id from {cv} WHERE name='%s')";
        }
    }
    $res=db_fetch_array(db_query($sql,$cvterm,$cv));
  }
  if (!empty($res['a'])){
    return $res['a'];
  }
  return FALSE;
}

function gmod_dbsf_decypher_dbxref($dbxref,$db=NULL){
  if (empty($dbxref)){return;}
  $sql = '';
  $is_chado = gmod_dbsf_is_chado();
  if (is_numeric($dbxref)){
    if ($is_chado === FALSE) {
      $sql = "SELECT accession as a from {gmod_dbsf_dbxref} where dbxref_id=$dbxref";
    }else{
      $sql = "SELECT accession as a from {dbxref} where dbxref_id=$dbxref";
    }
  }else{
    if ($is_chado === FALSE) {
      $sql = "SELECT dbxref_id as a  from {gmod_dbsf_dbxref} where accession ='$dbxref' AND db_id=(SELECT db_id from {gmod_dbsf_db} WHERE name='$db')";
    }else{
      $sql = "SELECT dbxref_id as a from {dbxref} where accession ='$dbxref' AND db_id=(SELECT db_id from {db} WHERE name='$db')";
    }
  }
  $res=db_fetch_array(db_query($sql));
  return $res['a'];
}

function gmod_dbsf_get_cvterm_details($cvterm_id=NULL,$cv=NULL) {
  if (empty($cvterm_id)){return;}
  if (!is_numeric($cvterm_id) && !empty($cv)){
    $cvterm_id=gmod_dbsf_decypher_cvterm($cvterm_id,$cv);
  }elseif (!is_numeric($cvterm_id)) {
    return;
  }
  $sql = '';
  $is_chado      = gmod_dbsf_is_chado();
  if ($is_chado === FALSE) {
    $sql = "SELECT cvterm_id,cvterm.name as cvterm_name,cv.name as cv_name,cvterm.definition as cvterm_def,cv.cv_id,cv.definition as cv_def from {gmod_dbsf_cvterm} "
    ." JOIN {gmod_dbsf_cv} on cvterm.cv_id = cv.cv_id where cvterm_id =$cvterm_id";
  }else{
    $sql = "SELECT cvterm_id,cvterm.name as cvterm_name,cv.name as cv_name,cvterm.definition as cvterm_def,cv.cv_id,cv.definition as cv_def from {cvterm} "
    ." JOIN {cv} on cvterm.cv_id = cv.cv_id where cvterm_id =$cvterm_id";
  }
  $data = db_fetch_array(db_query($sql));
  return $data;
}

function gmod_dbsf_get_dbxref_details($dbxref_id=NULL,$db=NULL) {
  if (empty($dbxref_id)){return;}
  if (!is_numeric($dbxref_id) && !empty($db)){
    $dbxref_id=gmod_dbsf_decypher_dbxref($dbxref_id,$db);
  }elseif (!is_numeric($dbxref_id)) {
    return;
  }
  $sql = '';
  $is_chado      = gmod_dbsf_is_chado();
  if ($is_chado === FALSE) {
    $sql = "SELECT dbxref_id,dbxref.accession as dbxref_name,db.name as db_name,dbxref.description as dbxref_def,db.db_id,db.description as db_def from {gmod_dbsf_dbxref} "
    ." JOIN {gmod_dbsf_db} on dbxref.db_id = db.db_id where dbxref_id =$dbxref_id";
  }else{
    $sql = "SELECT dbxref_id,dbxref.accession as dbxref_name,db.name as db_name,dbxref.description as dbxref_def,db.db_id,db.description as db_def from {dbxref} "
    ." JOIN {db} on dbxref.db_id = db.db_id where dbxref_id =$dbxref_id";
  }
  $data = db_fetch_array(db_query($sql));
  return $data;
}


/**
 * Get cvterms and properties for a feature
 *
 * @param $feature
 *   ID or name of feature to get cvterms and properties for.
 *
 * @return
 *   An associative array WHERE the primary key is 'cvterm' and 'prop' for
 *   cvterms and properties respectively. secondary key is the cvterm id or property rank
 *   'cvterm' is has cvterm.names in a list array foreach cv_name.
 *   'prop' does likewise for values of each cvterm.name
 *   'cvterm_def' is an array of cv+cvterm definitions in same order as cvterm
 *   'prop_def' is an array of cv+cvterm definitions in same order as prop
 */
function gmod_dbsf_get_feature_cvterm_and_prop($feature) {
  $return_array = array();
  if (empty($feature)) {
    return FALSE;
  }
  $is_chado      = gmod_dbsf_is_chado();
  $cvterm_select = '';
  $prop_select   = '';
  if ($is_chado === FALSE) {
    $cvterm_select = 'SELECT cv.definition as cv_def,cvterm.cvterm_id,cvterm.definition as cvterm_def,cvterm.name as cvterm_name,cv.name as cv_name FROM {gmod_dbsf_feature_cvterm} as r ' . ' JOIN {gmod_dbsf_cvterm} as cvterm ON r.cvterm_id=cvterm.cvterm_id' . ' JOIN {gmod_dbsf_cv} as cv ON cv.cv_id=cvterm.cv_id ';
    $prop_select = 'SELECT cv.definition as cv_def,cvterm.definition as cvterm_def,cvterm.name as cvterm_name,r.value,r.rank FROM {gmod_dbsf_featureprop} as r ' . ' JOIN {gmod_dbsf_cvterm} as cvterm ON r.type_id=cvterm.cvterm_id ';
  }
  else {
    $cvterm_select = 'SELECT cv.definition as cv_def,cvterm.cvterm_id,cvterm.definition as cvterm_def,cvterm.name as cvterm_name,cv.name as cv_name FROM feature_cvterm as r ' . ' JOIN cvterm ON r.cvterm_id=cvterm.cvterm_id' . ' JOIN cv ON cv.cv_id=cvterm.cv_id ';
    $prop_select = 'SELECT cv.definition as cv_def,cvterm.definition as cvterm_def,cvterm.name as cvterm_name,r.value,r.rank FROM featureprop as r ' . ' JOIN cvterm ON r.type_id=cvterm.cvterm_id ';
  }
  if (is_numeric($feature)) {
    $cvterm_select .= ' WHERE r.feature_id=%d ';
    $prop_select .= ' WHERE r.feature_id=%d ';
  }
  else {
    if ($is_chado === FALSE) {
      $cvterm_select .= " WHERE r.feature_id=(SELECT feature_id FROM {gmod_dbsf_feature} as feature WHERE uniquename='%s')";
      $prop_select .= " WHERE r.feature_id=(SELECT feature_id FROM {gmod_dbsf_feature} as feature WHERE uniquename='%s')";
    }
    else {
      $cvterm_select .= " WHERE r.feature_id=(SELECT feature_id FROM feature WHERE uniquename='%s')";
      $prop_select .= " WHERE r.feature_id=(SELECT feature_id FROM feature WHERE uniquename='%s')";
    }
  }

  $prop_select .= ' ORDER by r.rank';
  $cv_res = db_query($cvterm_select, $feature);
  while ($row = db_fetch_array($cv_res)) {
    $return_array['cvterm'][$row['cv_name']][$row['cvterm_id']] = $row['cvterm_name'];
    $return_array['cvterm_def'][$row['cv_name']][$row['cvterm_id']] = array($row['cv_def'],$row['cvterm_def']);
  }
  $prop_res = db_query($prop_select, $feature);
  while ($row = db_fetch_array($prop_res)) {
    $return_array['prop'][$row['cvterm_name']][$row['rank']] = $row['value'];
    $return_array['prop_def'][$row['cvterm_name']][$row['rank']] = array($row['cv_def'],$row['cvterm_def']);
  }
  if (!empty($return_array)) {
    return $return_array;
  }
  else {
    return FALSE;
  }
}

/**
 * Rename a feature
 *
 * @param $old_name
 *   feature's current uniquename
 * @param $new_name
 *   New uniquename to set for $old_name feature
 *
 * @return
 *   TRUE on success and FALSE on failure. On failure it also sets a message.
 */
function gmod_dbsf_rename_feature($old_name, $new_name) {
  if (empty($old_name) || empty($new_name)) {
    return FALSE;
  }
  $is_chado   = gmod_dbsf_is_chado();
  $select_sql = '';
  $update_sql = '';
  if ($is_chado === FALSE) {
    $select_sql = "SELECT feature_id FROM {gmod_dbsf_feature} as feature WHERE uniquename='%s'";
    $update_sql = "UPDATE {gmod_dbsf_feature} SET uniquename='%s' WHERE uniquename='%s'";
  }
  else {
    $select_sql = "SELECT feature_id FROM feature WHERE uniquename='%s'";
    $update_sql = "UPDATE feature SET uniquename='%s' WHERE uniquename='%s'";
  }
  $res = db_fetch_array(db_query($select_sql, $old_name));
  if (empty($res['feature_id'])) {
    drupal_set_message(t('Failed to rename as I cannot find %old_name', array('%old_name' => $old_name)), 'error');
    return FALSE;
  }
  db_query($update_sql, $new_name, $old_name);
  $res = db_fetch_array(db_query($select_sql, $new_name));
  if (empty($res['feature_id'])) {
    drupal_set_message(t('For some reason, I failed to rename %old_name to %new_name', array('%new_name' => $new_name, '%old_name' => $old_name)), 'error');
    return FALSE;
  }
  return TRUE;
}

/**
 * Write a FASTA file to a destination
 *
 * Used when uploading FROM a form
 *
 * @param $infile
 *   Full path to input file, e.g. one uploaded into temp dir /tmp/temp.txt
 * @param $outfile
 *   Desired destination (including filename) for FASTA file.
 * @param $delete
 *   A boolean of whether to delete the input file after transfer.
 * @param $definition
 *   If there is no definition line, you can provide one here
 *
 * @return
 *   TRUE on success
 */
function gmod_dbsf_write_fastafile($infile = NULL, $outfile = NULL, $delete = NULL, $definition = NULL) {
  if (empty($infile) || empty($outfile)) {
    return FALSE;
  }
  // OS compatibility
  ini_set('auto_detect_line_endings', TRUE);
  //decided against checking for individual characters (too slow). check outfile writability
  if (!$outhandle = fopen($outfile, 'wb')) {
    drupal_set_message(t('Could not create %outfile.', array('%outfile' => $outfile)), 'error');
    return FALSE;
  }
  //file
  if (file_exists($infile)) {
    // read infile and store in outfile as we go along
    // if no defline is found at all, then make one.
    $defline_found = !empty($definition) ? TRUE : FALSE;
    if ($inhandle = fopen($infile, 'rb')) {
      while (!feof($inhandle)) {
        $line = trim(fgets($inhandle));
        if (!empty($line)) {
          $defline = strpos($line, '>');
          if ($defline !== FALSE) {
            $defline_found = TRUE;
            // '>' char does not begin at the begining. delete anything before it
            if ($defline > 0) {
              $line = substr($line, $defline);
            }
          }
          if (!empty($line)) {
            $data = $line ."\n";
            // no empty lines
            if (!empty($data)) {
              fwrite($outhandle, $data);
            }
          }
        }
      }
      fclose($inhandle);
    }
    fclose($outhandle);
    if ($defline_found != TRUE) {
      //add defline at beginning of file
      $outhandle2 = fopen($outfile .'tmp', 'wb');
      if (!empty($outhandle2)) {
        if (!empty($definition)) {
          fwrite($outhandle2, "\n" . '>'. $definition ."\n");
        }
        else {
          fwrite($outhandle2, "\n>Unknown_Query\n");
        }
      }
      else {
        drupal_set_message(t('Cannot write to temporary directory, this should not have happened. Please ') . l('contact', 'contact') . t(' the administrator.'), 'error');
        return FALSE;
      }
      $inhandle = fopen($outfile, 'rb');
      while (!feof($inhandle)) {
        fwrite($outhandle2, fgets($inhandle));
      }
      fclose($inhandle);
      fclose($outhandle2);
    }
  }
  //text:
  else {
    $seq_array = explode("\r", $infile);
    if (!empty($definition)) {
      fwrite($outhandle, "\n" . '>'. $definition ."\n");
      foreach ($seq_array as $line) {
        $line = trim($line);
        if (!empty($line)) {
          $defline = strpos($line, '>');
          if ($defline !== FALSE) {
            continue;
          }
        }
        if (!empty($line)) {
          $data = $line ."\n";
          // no empty lines
          if (!empty($data)) {
            fwrite($outhandle, $data);
          }
        }
      }
    }
    else {
      $defline_found = FALSE;
      foreach ($seq_array as $line) {
        $defline = strpos($line, '>');
        if ($defline !== FALSE) {
          $defline_found = TRUE;
          break;
        }
      }
      if ($defline_found === FALSE) {
        array_unshift($seq_array, "\n" . '>Unknown_Query');
        $defline_found = TRUE;
      }
      foreach ($seq_array as $line) {
        $line = trim($line);
        if (!empty($line)) {
          $defline = strpos($line, '>');
          if ($defline !== FALSE) {
            if ($defline > 0) {
              $line = substr($line, $defline);
            }
          }
          if (!empty($line)) {
            $data = $line ."\n";
            // no empty lines
            if (!empty($data)) {
              fwrite($outhandle, $data);
            }
          }
        }
      }
    }
    fclose($outhandle);
  }

  if (!empty($delete) && $delete === TRUE && file_exists($infile)) {
    file_delete($infile);
  }
  return TRUE;
}

/**
 * Create a checkbox tree of species and their phylogeny
 *
 * @param $phylogeny_array
 * Phylogeny array FROM gmod_dbsf_getspecies
 * @param $button
 * If set then give data for a button. Keys are description (used during hovering),title and validate
 * The $button can be TRUE or a validation function callback
 * @see genes4all_explore_select_species_form
 *
 * @return
 * form API item;
 */
function gmod_dbsf_phylogeny_tree($phylogeny_array, $button = NULL) {
  static $ic_phylogeny_loaded;
  if ($ic_phylogeny_loaded !== TRUE) {
    drupal_add_css(drupal_get_path('module', 'gmod_dbsf') .'/includes/dynatree/skin/ui.dynatree.css', 'module', 'all', FALSE);
    jquery_ui_add('ui.core');
    drupal_add_js(drupal_get_path('module', 'gmod_dbsf') .'/includes/dynatree/jquery.dynatree.min.js');
    drupal_add_js(drupal_get_path('module', 'gmod_dbsf') .'/includes/gmod_dbsf_phylogeny_tree.js');
    $ic_phylogeny_loaded = TRUE;
  }
  $form            = array();
  $species_index   = 0;
  $form['species'] = array(
    '#type' => 'fieldset',
    '#title' => t('Phylogeny'),
    '#description'=>t('Select one ore more species. If you select a taxon, it will automatically select all the species for you.'),
    '#tree' => FALSE,
  );
  $form['species']['species_select'][$species_index] = array(
    '#type' => 'markup',
    '#value' => '<div id="checktree"><ul id="root">',
    '#weight' => -2,
  );
  $species_index++;
  ksort($phylogeny_array);
  foreach ($phylogeny_array as $class => $order_array) {
    if (empty($order_array)) {
      continue;
    }
    ksort($order_array);
    // NOTE the <li id must exist and match the key set by the FAPI but only for the leaf nodes...
    //TODO for some reason i cannot get the parent array to populate. here i use it to reduce the number of elements in the vlaue array and have the species only be presnt thre.
    //then a very inefficient approach at the form_alter function checks if this is a species array...
    $form['species']['species_select'][$species_index] = array(
      '#parents' => array('phylogeny_select', 'class', $class),
      '#type' => 'checkbox',
      '#title' => $class,
      '#return_value' => 'class-'. $class,
      '#attributes' => array('class' => 'hidden-checkbox'),
      '#weight' => $species_index,
      '#prefix' => "<li data='icon: false,expand: true' />",
    );
    $species_index++;
    $form['species']['species_select'][$species_index] = array(
      '#type' => 'markup',
      '#value' => "<ul id='$class'>",
      '#weight' => $species_index,
    );
    $species_index++;
    foreach ($order_array as $order => $family_array) {
      if (empty($family_array)) {
        continue;
      }
      $form['species']['species_select'][$species_index] = array(
        '#parents' => array('phylogeny_select', 'order', $order),
        '#type' => 'checkbox',
        '#title' => $order,
        '#return_value' => 'order-'. $order,
        '#attributes' => array('class' => 'hidden-checkbox'),
        '#weight' => $species_index,
        '#prefix' => "<li data='icon: false' />",
      );
      $species_index++;
      $form['species']['species_select'][$species_index] = array(
        '#type' => 'markup',
        '#value' => "<ul id='$order'>",
        '#weight' => $species_index,
      );
      $species_index++;

      foreach ($family_array as $family => $species_data) {
        if (empty($species_data)) {
          continue;
        }
        $form['species']['species_select'][$species_index] = array(
          '#parents' => array('phylogeny_select', 'family', $family),
          '#type' => 'checkbox',
          '#attributes' => array('class' => 'hidden-checkbox'),
          '#title' => $family,
          '#return_value' => 'family-'. $family,
          '#weight' => $species_index,
          '#prefix' => "<li data='icon: false' >",
        );
        $species_index++;
        $form['species']['species_select'][$species_index] = array(
          '#type' => 'markup',
          '#value' => "<ul id='$family'>",
          '#weight' => $species_index,
        );
        $species_index++;
        foreach ($species_data as $species_id => $species_name) {
          $form['species']['species_select'][$species_index] = array(
          //  '#parents' => array('phylogeny_select','species',$species_id),
            '#type' => 'checkbox',
            '#title' => $species_name,
            '#return_value' => 'species-'. $species_id,
            '#attributes' => array('class' => 'hidden-checkbox'),
            '#weight' => $species_index,
            '#prefix' => "<li data='icon: false' id='$species_index'>",
          );
          $species_index++;
        }
        $form['species']['species_select'][$species_index] = array(
          '#type' => 'markup',
          '#value' => "</ul id='$family'>",
          '#weight' => $species_index,
        );
        $species_index++;
      }

      $form['species']['species_select'][$species_index] = array(
        '#type' => 'markup',
        '#value' => "</ul id='$order'>",
        '#weight' => $species_index,
      );
      $species_index++;
    }

    $form['species']['species_select'][$species_index] = array(
      '#type' => 'markup',
      '#value' => "</ul id='$class'>",
      '#weight' => $species_index,
    );
    $species_index++;
  }
  $form['species']['species_select'][$species_index] = array(
    '#type' => 'markup',
    '#weight' => $species_index,
    '#value' => '</ul id="root"></div id="checktree">',
  );
  $species_index++;
  if (!empty($button)) {
    $form['species']['species_filter'] = array(
      '#type' => 'submit',
      '#attributes' => array('title' => $button['description'], "onclick" => "this.value='Fetching data';"),
      '#value' => $button['title'],
      '#validate' => array($button['validate']),
      '#weight' => $species_index,
    );
  }
  return $form;
}

/**
 * This submit button will clear any form which calls it, incl. storage and values
 * but will not rebuild the form
 *
 * Used as a hook_form_validate or hook_form_submit
 * @ingroup forms
 *
 * @param $form
 *   hook_form data
 * @param $form_state
 *   hook_form data
 *
 * @see genes4all_explore_search_species_form()
 */
function gmod_dbsf_form_clear_norebuild(&$form, &$form_state) {
  $form_state['rebuild'] = FALSE;
  unset($form_state['values']);
  unset($form_state['storage']);
}

/**
 * This submit button will clear any form which calls it, incl. storage and values
 * It will rebuild the form.
 *
 * Used as a hook_form_validate or hook_form_submit
 * @ingroup forms
 *
 * @param $form
 *   hook_form data
 * @param $form_state
 *   hook_form data
 *
 * @see genes4all_explore_search_species_form()
 */
function gmod_dbsf_form_clear(&$form, &$form_state) {
  $form_state['rebuild'] = TRUE;
  unset($form_state['values']);
  unset($form_state['storage']);
}


/**
 * Delete a file if older than 7  days.
 *
 * Used with cron
 * @see gmod_dbsf_download_cron()
 * @see biosoftware_bench_cron()
 *
 * @param $file
 *   File to delete
 */
function gmod_dbsf_delete_temp($file = NULL, $deftime = 604800) {
  if (empty($file)) {
    return FALSE;
  }
  //one day=86400 sec;defaults to 7 days
  $crontime = $deftime;
  // for DBSF only:
  if (strpos($file, 'dbss') !== FALSE && $deftime !== 1) {
    //days
    $crontime = gmod_dbsf_get_add_var('gmod_dbsf_dbss_cron_cleanup');
    if (empty($crontime) || !is_numeric($crontime)) {
      $crontime = $deftime;
    }
    else {
      $crontime = $crontime * 86400;
    }
  }
  $timestamp = time();
  $age = filemtime($file);
  if (!empty($age) && !empty($timestamp)) {
    $diff = $timestamp - $age;
    if ($diff > $crontime) {
      file_delete($file);
    }
  }
}

/**
 * Get organism data using an organism id or binomial name
 *
 * @param $organism_id
 * The internal organism ID or latin name or NCBI taxonomy ID if in form of NCBI\\d+
 */
function gmod_dbsf_decypher_organism_id($organism_id, $full_access = FALSE) {
  if (empty($organism_id)) {
    return FALSE;
  }
  $is_chado = gmod_dbsf_is_chado();
  $sql_select = '';
  if (!is_numeric($organism_id)) {
    if (stripos($organism_id, 'ncbi') === FALSE) {
      preg_match('/^(\w+)[\s_]+(.+)/', $organism_id, $data);
      $genus = $data[1];
      $species = strtr($data[2], '_', ' ');
      if ($is_chado === FALSE) {
        $sql_select = "SELECT genus,species,organism_id FROM {gmod_dbsf_organism} WHERE genus='$genus' AND species='$species'";
      }
      else {
        $sql_select = "SELECT genus,species,organism_id FROM organism WHERE genus='$genus' AND species='$species'";
      }
    }
    else {
      preg_match('/(\d+)/', $organism_id, $data);
      if ($is_chado === FALSE) {
        $sql_select = "SELECT genus,species,organism_id FROM {gmod_dbsf_organism} as organism WHERE ncbi_taxid=". $data[1];
      }
      else {
        $sql_select = "SELECT genus,species,organism_id FROM organism WHERE organism_id=" . "(select organism_id FROM organism_dbxref WHERE dbxref_id=" . "(select dbxref_id FROM dbxref join db on dbxref.db_id=db.db_id WHERE dbxref.accession='". $data[1] ."' AND db.name='NCBI_TAXONOMY')" . ")";
      }
    }
  }
  else {
    if ($is_chado === FALSE) {
      $sql_select = "SELECT genus,species,organism_id FROM {gmod_dbsf_organism} as organism WHERE organism_id=$organism_id";
    }
    else {
      $sql_select = "SELECT genus,species,organism_id FROM organism WHERE organism_id=$organism_id";
    }
  }
  $dbdata = db_fetch_array(db_query($sql_select));
  if (empty($dbdata)) {
    return FALSE;
  }
  if ($is_chado !== FALSE && $full_access !== TRUE ) {
    $access = gmod_dbsf_chadoapi_check_restriction('select', 'organism', $dbdata['organism_id'], FALSE);
    if (empty($access)) {
      return FALSE;
    }
  }
  return array('genus' => $dbdata['genus'], 'species' => $dbdata['species'], 'organism_id' => $dbdata['organism_id'],'id'=>$dbdata['organism_id']);
}

/**
 * Check if the user has access to a Chado resource
 *
 * This is a Chado specific function. It will connect to Chado internally.
 * Like all chadoapi functions it must not be part of _chado.module as it
 * is used in a dependency (in this case, the gmod_dbsf.module itself)
 * @TODO implement it for Drupal as well
 *
 * @param $restrict_type
 * The type of restriction sought, e.g. 'select','update','create','delete'
 * see CV ic_data_restrictions
 * @param $resource_type
 * What kind of resource: library, organism or feature
 * @param $id
 * The internal Chado id of the resource.
 * @param $reconnect
 * If true then it will reconnect to Drupal. Otherwise stay in Chado (careful!)
 *
 * @return
 * TRUE on pass, FALSE otherwise
 */
function gmod_dbsf_chadoapi_check_restriction($restrict_type, $resource_type, $id, $reconnect = TRUE) {
  if (empty($restrict_type) || empty($resource_type) || empty($id)) {
    return FALSE;
  }
  global $user;
  $user_membership_array = (array)$user->roles;
  if (!empty($user->name)){
    $user_membership_array = array_merge($user_membership_array, (array)$user->name);
  }
  switch ($resource_type) {
    // in hierarchical order, anything below searches also the ones on the top.

    case 'organism':
      $select_restriction_sql = "SELECT organism_id as id,value FROM organismprop WHERE " . " organism_id = %d AND " . " type_id =(select cvterm_id FROM cvterm WHERE name='%s' AND cv_id" . "=(select cv_id FROM cv WHERE name='ic_data_restrictions'))";
      gmod_dbsf_db_execute('chado');
      $select_restriction_db = db_query($select_restriction_sql, $id, $restrict_type);
      $select_restrictions_array = array();
      while ($select_restrictions = db_fetch_array($select_restriction_db)) {
        $select_restrictions_array[$select_restrictions['id']][] = $select_restrictions['value'];
      }
      if (!empty($reconnect)) {
        gmod_dbsf_db_execute();
      }
      if ((!empty($select_restrictions_array[$id]) && (array_intersect($user_membership_array, $select_restrictions_array[$id])))
      || empty($select_restrictions_array[$id])
      ) {
        return TRUE;
      }
      break;

    case 'library':
      $select_restriction_sql = "select organism_id as id,value FROM organismprop WHERE " . " organism_id = (SELECT organism_id FROM library WHERE library_id=%d) AND " . " type_id =(select cvterm_id FROM cvterm WHERE name='%s' AND cv_id" . "=(select cv_id FROM cv WHERE name='ic_data_restrictions'))";
      gmod_dbsf_db_execute('chado');
      $select_restriction_db = db_query($select_restriction_sql, $id, $restrict_type);
      $select_restrictions_array = array();
      while ($select_restrictions = db_fetch_array($select_restriction_db)) {
        $select_restrictions_array[] = $select_restrictions['value'];
      }
      if (!empty($reconnect)) {
        gmod_dbsf_db_execute();
      }
      if ((!empty($select_restrictions_array) && (array_intersect($user_membership_array, $select_restrictions_array)))) {
        return TRUE;
      }
      elseif (!empty($select_restrictions_array)) {
        return FALSE;
      }
      $select_restriction_sql = "select library_id as id,value FROM libraryprop WHERE " . " library_id = %d AND " . " type_id =(select cvterm_id FROM cvterm WHERE name='%s' AND cv_id" . "=(select cv_id FROM cv WHERE name='ic_data_restrictions'))";
      gmod_dbsf_db_execute('chado');
      $select_restriction_db = db_query($select_restriction_sql, $id, $restrict_type);
      $select_restrictions_array = array();
      while ($select_restrictions = db_fetch_array($select_restriction_db)) {
        $select_restrictions_array[$select_restrictions['id']][] = $select_restrictions['value'];
      }
      if (!empty($reconnect)) {
        gmod_dbsf_db_execute();
      }
      if ((!empty($select_restrictions_array[$id]) && (array_intersect($user_membership_array, $select_restrictions_array[$id])))
      || empty($select_restrictions_array[$id])
      ) {
        return TRUE;
      }
      break;

    case 'feature':
      $select_restriction_sql = "select organism_id as id,value FROM organismprop WHERE " . " organism_id = (SELECT organism_id FROM feature WHERE feature_id=%d) AND " . " type_id =(select cvterm_id FROM cvterm WHERE name='%s' AND cv_id" . "=(select cv_id FROM cv WHERE name='ic_data_restrictions'))";
      gmod_dbsf_db_execute('chado');
      $select_restriction_db = db_query($select_restriction_sql, $id, $restrict_type);
      $select_restrictions_array = array();
      while ($select_restrictions = db_fetch_array($select_restriction_db)) {
        $select_restrictions_array[] = $select_restrictions['value'];
      }
      if (!empty($reconnect)) {
        gmod_dbsf_db_execute();
      }
      if ((!empty($select_restrictions_array) && (array_intersect($user_membership_array, $select_restrictions_array)))) {
        return TRUE;
      }
      elseif (!empty($select_restrictions_array)) {
        return FALSE;
      }
      $select_restriction_sql = "select library_id as id,value FROM libraryprop WHERE " . " library_id = (SELECT library_id FROM library_feature WHERE feature_id=%d) AND " . " type_id =(select cvterm_id FROM cvterm WHERE name='%s' AND cv_id" . "=(select cv_id FROM cv WHERE name='ic_data_restrictions'))";
      gmod_dbsf_db_execute('chado');
      $select_restriction_db = db_query($select_restriction_sql, $id, $restrict_type);
      $select_restrictions_array = array();
      while ($select_restrictions = db_fetch_array($select_restriction_db)) {
        $select_restrictions_array[] = $select_restrictions['value'];
      }
      if (!empty($reconnect)) {
        gmod_dbsf_db_execute();
      }
      if ((!empty($select_restrictions_array) && (array_intersect($user_membership_array, $select_restrictions_array)))) {
        return TRUE;
      }
      elseif (!empty($select_restrictions_array)) {
        return FALSE;
      }
      $select_restriction_sql = "select feature_id as id,value FROM featureprop WHERE " . " feature_id = %d AND " . " type_id =(select cvterm_id FROM cvterm WHERE name='%s' AND cv_id" . "=(select cv_id FROM cv WHERE name='ic_data_restrictions'))";
      gmod_dbsf_db_execute('chado');
      $select_restriction_db = db_query($select_restriction_sql, $id, $restrict_type);
      $select_restrictions_array = array();
      while ($select_restrictions = db_fetch_array($select_restriction_db)) {
        $select_restrictions_array[$select_restrictions['id']][] = $select_restrictions['value'];
      }
      if (!empty($reconnect)) {
        gmod_dbsf_db_execute();
      }
      if ((!empty($select_restrictions_array[$id]) && (array_intersect($user_membership_array, $select_restrictions_array[$id])))
      || empty($select_restrictions_array[$id])
      ) {
        return TRUE;
      }
      break;
  }
  return FALSE;
}

/**
 * Get species
 *
 * We want to use genus/species instead of organism_id in order to allow
 * potential future taxonomic searches
 * Unless $all_orgs is given, it gives only organisms with features
 *
 * @see gmod_dbsf_get_add_organism()
 * @todo move into gmod_dbsf_get_add_organism();
 *
 * @param $limit
 * a string of comma delimited numbers or an array of organism_id
 * @param $all_orgs
 * if not empty, it gets all organisms, even those without contigs or other features.
 * This is only for Chado, as Drupal always gets all organisms.
 *
 * This function checks for restrictions if the connection is to the Chado db
 *
 * @return
 * associative array: 'species_array' and 'phylogeny_array' as keys
 */
function gmod_dbsf_getspecies($limit = NULL, $all_orgs = NULL) {
  $species_array    = array();
  $phylogeny_array  = array();
  $is_chado         = gmod_dbsf_is_chado();
  $phylogeny_sql    = "SELECT cvterm.name as taxon,value FROM organismprop "
  . " join cvterm on cvterm.cvterm_id=organismprop.type_id WHERE "
  . " organism_id=%d AND cvterm.name IN ('class','order','family')"
  . " AND cv_id=(select cv_id FROM cv WHERE name='NCBI_TAXONOMY_RANKS')";
  $get_org_data_sql = "select organism_id,genus,species,common_name,abbreviation,num_features " . " FROM organism natural join type_feature_count_org_mat WHERE type='contig' ";
  if (!empty($all_orgs)) {
    $get_org_data_sql = "select organism_id,genus,species,common_name,abbreviation FROM organism organism WHERE TRUE ";
  }
  if ($is_chado === FALSE) {
    $get_org_data_sql = "SELECT organism_id,tax_class as class,tax_order as order,tax_family as family,genus,species, ncbi_taxid,common_name"
    . " FROM {gmod_dbsf_organism} WHERE TRUE ";
  }/*else{
  $md5=md5('org'.$limit.$all_orgs.$is_chado);
  if ($is_chado==TRUE){db_set_active();}
  $org_data = cache_get('ORG_'.$md5,'cache_gmod_dbsf');
  if ($is_chado==TRUE){db_set_active('chado');}
  if (!empty($table_array)){
  return $org_data->data;
  }
  }*/

  if (!isset($limit) || empty($limit) || $limit == "all") {
    $result = db_query($get_org_data_sql ." order by genus,species");
    while ($dbdata = db_fetch_array($result)) {
      $friendly = $dbdata['common_name'];
      if (empty($friendly)) {
        $friendly = $dbdata['abbreviation'];
      }
      if (empty($friendly)) {
        $friendly = substr($dbdata['genus'], 0, 1) .". ". $dbdata['species'];
      }
      $access = '';
      if ($is_chado === FALSE) {
        $access = TRUE;
      }
      else {
        $access = gmod_dbsf_chadoapi_check_restriction('select', 'organism', $dbdata['organism_id'], FALSE);
      }
      if ($access == TRUE) {
        $binomial = $dbdata['genus'] ." ". $dbdata['species'];
        if (!empty($friendly) || !empty($dbdata['num_features'])) {
          $binomial .= " (";
          if (!empty($friendly)) {
            $binomial .= $friendly;
          }
          if (!empty($dbdata['num_features'])) {
            $binomial .= ' : '. $dbdata['num_features'].' features';
          }
          $binomial .= ")";
        }
        if ($is_chado === FALSE) {
          $phylogeny_array[$dbdata['organism_id']]['class'] = $dbdata['class'];
          $phylogeny_array[$dbdata['organism_id']]['order'] = $dbdata['order'];
          $phylogeny_array[$dbdata['organism_id']]['family'] = $dbdata['family'];
        }
        else {
          $phylogeny_result = db_query($phylogeny_sql, $dbdata['organism_id']);
          while ($db_phylogeny_data = db_fetch_array($phylogeny_result)) {
            $phylogeny_array[$dbdata['organism_id']][$db_phylogeny_data['taxon']] = $db_phylogeny_data['value'];
          }
        }
        $species_array[$dbdata['organism_id']] = $binomial;
      }
    }
  }
  // else there is a limit
  else {
    if (is_array($limit)) {
      $limit = implode(',', $limit);
    }
    $result = db_query($get_org_data_sql ." AND organism_id IN ($limit) order by genus,species");
    while ($dbdata = db_fetch_array($result)) {
      $friendly = $dbdata['common_name'];
      if (empty($friendly)) {
        $friendly = $dbdata['abbreviation'];
      }
      if (empty($friendly)) {
        $friendly = substr($dbdata['genus'], 0, 1) .". ". $dbdata['species'];
      }
      if ($is_chado === FALSE) {
        $access = TRUE;
      }
      else {
        $access = gmod_dbsf_chadoapi_check_restriction('select', 'organism', $dbdata['organism_id'], FALSE);
      }
      if ($access == TRUE) {
        $binomial = $dbdata['genus'] ." ". $dbdata['species'];
        if (!empty($friendly) || !empty($dbdata['num_features'])) {
          $binomial .= " (";
          if (!empty($friendly)) {
            $binomial .= $friendly;
          }
          if (!empty($dbdata['num_features'])) {
            $binomial .= ' : '. $dbdata['num_features'];
          }
          $binomial .= ")";
        }
        if ($is_chado === FALSE) {
          $phylogeny_array[$dbdata['organism_id']]['class'] = $dbdata['class'];
          $phylogeny_array[$dbdata['organism_id']]['order'] = $dbdata['order'];
          $phylogeny_array[$dbdata['organism_id']]['family'] = $dbdata['family'];
        }
        else {
          $phylogeny_result = db_query($phylogeny_sql, $dbdata['organism_id']);
          while ($db_phylogeny_data = db_fetch_array($phylogeny_result)) {
            $phylogeny_array[$dbdata['organism_id']][$db_phylogeny_data['taxon']] = $db_phylogeny_data['value'];
          }
        }
        $species_array[$dbdata['organism_id']] = $binomial;
      }
    }
  }
  if (!isset($species_array)) {
    //TODO verify this doesn't need changing.
    $species_array = array('None' => 'None allowed');
  }
  // re-order array
  $phylogeny_array2 = array();
  foreach ($phylogeny_array as $species => $array) {
    $phylogeny_array2[$array['class']][$array['order']][$array['family']][$species] = $species_array[$species];
  }
  /*if ($is_chado == TRUE) {
   if ($is_chado==TRUE){db_set_active();}
   cache_set('ORG_'.$md5,array('species_array' => $species_array, 'phylogeny_array' => $phylogeny_array2), 'cache_gmod_dbsf');
   if ($is_chado==TRUE){db_set_active('chado');}
   }
   */
  return array('species_array' => $species_array, 'phylogeny_array' => $phylogeny_array2);
}

/**
 * Install a postgres function unless it already exists
 *
 * @param $name
 * Name of function to check if it already exists
 * @param $sql
 * Complete SQL to create function (include 'CREATE')
 */
function gmod_dbsf_install_pgfunction($name, $sql) {
  if (empty($name) || empty($sql)) {
    return FALSE;
  }
  $sql_check = "select proname FROM pg_catalog.pg_proc WHERE proname='%s'";
  $res_check = db_fetch_array(db_query($sql_check, $name));
  if (empty($res_check)) {
    db_query($sql);
  }
  $res_check = db_fetch_array(db_query($sql_check, $name));
  if (empty($res_check)) {
    drupal_set_message(t('Failed to insert function %name. Perhaps permissions are not set as writable?', array('%name' => $name)), 'error');
    return FALSE;
  }

  return TRUE;
}

/**
 * Install a views on your database
 *
 * @param $variables
 * Associative array WHERE 'view_name' is name of the view and 'spec' is the SQL which builds the view
 *
 * @return
 * FALSE on failure, TRUE on success
 */
function gmod_dbsf_install_dbviews($variables) {
  global $user;
  $view_name = $variables['view_name'];
  $spec = $variables['spec'];
  $is_chado         = gmod_dbsf_is_chado();
  if (!empty($user)) {
    $user = $variables['user'];
  }else{
    if ($is_chado === TRUE){
      $user = 'chado_dbuser';
    }
  }
  if (empty($view_name) || empty($spec)) {
    return FALSE;
  }
  $sql_drop = "DROP VIEW $view_name";
  $sql_create = "CREATE VIEW $view_name AS $spec";
  $sql_grant  = "GRANT SELECT on $view_name to $user";
  $exists     = db_table_exists($view_name);
  if (empty($exists)) {
    db_query($sql_create);
    if (!empty($user)){
      db_query($sql_grant);
    }
    $exists = db_table_exists($view_name);
    if (empty($exists)) {
      gmod_dbsf_drupal_set_message(gmod_dbsf_t('Failed to create view %view_name.', array('%view_name' => $view_name)), 'error');
      return FALSE;
    }
    else {
      db_query($sql_drop);
      db_query($sql_create);
      if (!empty($user)){
        db_query($sql_grant);
      }
      $exists = db_table_exists($view_name);
      if (empty($exists)) {
        gmod_dbsf_drupal_set_message(gmod_dbsf_t('Failed to create view %view_name.', array('%view_name' => $view_name)), 'error');
        return FALSE;
      }
    }
  }
  gmod_dbsf_drupal_set_message(gmod_dbsf_t('View %view_name created in your database.', array('%view_name' => $view_name)), 'warning');
  return TRUE;
}

/**
 * Convert database URLs to DSN
 *
 * e.g. from 'chado' => pgsql://alexie:123@localhost:5432/chado_test
 * to  'chado' => dbi:Pg:dbname=chado_test;host=localhost;port=5432;user=alexie;password=123
 *
 * @return array with same keys as $db_url
 */
function gmod_dbsf_db2dsn(){
  global $db_url;
  $return_array = array();
  if (is_array($db_url)){
    foreach ($db_url as $key => $url){
      $array = parse_url($url);
      $dbi = urldecode($array['scheme']);
      if ($dbi == 'pgsql'){
        $dbi ='Pg';
      }
      $return_array[$key] = "dbi:$dbi:dbname=".substr(urldecode($array['path']), 1)
      .';host='.urldecode($array['host'])
      .';port='.urldecode($array['port'])
      .';user='.urldecode($array['user'])
      .';password='.urldecode($array['pass']);
    }
  }else{
    $array=parse_url($db_url);
    $dbi = urldecode($array['scheme']);
    if ($dbi == 'pgsql'){
      $dbi ='Pg';
    }
    $return_array['default'] = "dbi:$dbi:dbname=".substr(urldecode($array['path']), 1)
    .';host='.urldecode($array['host'])
    .';port='.urldecode($array['port'])
    .';user='.urldecode($array['user'])
    .';password='.urldecode($array['pass']);
  }
  return $return_array;
}

/**
 * Get database key in $db_url using a database name
 *
 * @param $db_name, defaults to current connection
 * @return string database key
 */
function gmod_dbsf_db_key($db_name=NULL){
  if (empty($db_name)){
    global $active_db;
    $db_name = pg_dbname($active_db);
  }
  global $db_url;
  $db_key='default';
  // if db_url is a string, then the key is always default (i.e. the Drupal database)
  // otherwise, if it is an array...
  if (is_array($db_url)){
    foreach ($db_url as $key=>$url){
      $data = explode('/',$url);
      if (array_pop($data) === $db_name ){
        $db_key = $key;
        break;
      }
    }
  }
  return $db_key;
}

/**
 * Helper function to set_message when connected to a secondary database
 *
 * @see drupal_set_message()
 * This ensures that the proper connection to the Drupal database is connected
 * before attempting to store a message. The connection to the original database
 * is restored. The input parameters are exactly as in drupal_set_message
 *
 * @param $message
 * @param $type
 * @param $repeat
 *
 */
function gmod_dbsf_drupal_set_message($message,$type='status',$repeat=TRUE){
  if (empty($message)){return;}
  $current_db = gmod_dbsf_db_key();
  gmod_dbsf_db_execute();
  drupal_set_message($message,$type,$repeat);
  gmod_dbsf_db_execute($current_db);
}

/**
 * Helper function to t() when connected to a secondary database
 *
 * @see t()
 * This ensures that the proper connection to the Drupal database is connected
 * before attempting to t(). The connection to the original database
 * is restored. The input parameters are exactly as in t()
 *
 * @param $string
 * @param $args
 * @param $langcode
 * @return unknown_type
 */
function gmod_dbsf_t($string, $args = array(), $langcode = NULL){
  if (empty($string)){return;}
  $current_db = gmod_dbsf_db_key();
  if ($current_db !=='default'){
    gmod_dbsf_db_execute();
    t($string,$args,$langcode);
    gmod_dbsf_db_execute($current_db);
  }else{
    t($string,$args,$langcode);
  }
}


/**
 * Create a new materialized view in chado
 *
 * Uses the materialized_view table to add views. It is not part of the _chado
 * submodule because the _chado.install uses it.
 *
 * @param $data
 * An associative array with 'refresh_time','name','mv_schema','mv_table',
 * 'indexed','query' and 'special_index' relating to the relevant Chado
 * columns
 *
 * @return unknown_type
 */
function gmod_dbsf_chadoapi_add_mat_view($data) {
  if (empty($data)) {
    return FALSE;
  }

  //refresh_time,name,mv_schema,mv_table,mv_specs,indexed,query,special_index
  $refresh_time  = !empty($data['refresh_time']) ? $data['refresh_time'] : '';
  $name          = !empty($data['name']) ? $data['name'] :'';
  $mv_schema     = !empty($data['mv_schema']) ? $data['mv_schema'] :'';
  $mv_table      = !empty($data['mv_table']) ? $data['mv_table'] :'';
  $mv_specs      = !empty($data['mv_specs']) ? $data['mv_specs'] :'';
  $indexed       = !empty($data['indexed']) ? $data['indexed'] :'';
  $query         = !empty($data['query']) ? $data['query'] :'';
  $special_index = !empty($data['special_index']) ? $data['special_index'] :'';
  $last_update = !empty($data['last_update']) ? $data['last_update'] :'2000-01-01';
  if (empty($name)) {
    return FALSE;
  }
  gmod_dbsf_db_execute('chado_edit');
  $check_sql  = "SELECT materialized_view_id as id FROM materialized_view WHERE name='$name'";
  $insert_sql = 'INSERT INTO materialized_view (refresh_time,name,mv_schema,mv_table,mv_specs,indexed,query,special_index) VALUES ('. "$refresh_time,'$name','$mv_schema','$mv_table','$mv_specs','$indexed','$query','$special_index'" . ')';
  $exists     = db_fetch_array(db_query($check_sql));
  if (!empty($exists['id'])) {
    gmod_dbsf_db_execute();
    return 'EXISTS';
  }
  db_query($insert_sql);
  $exists = db_fetch_array(db_query($check_sql));
  if (empty($exists['id'])) {
    gmod_dbsf_db_execute();
    return FALSE;
  }
  else {
    gmod_dbsf_db_execute();
    return TRUE;
  }
}

/**
 * Install a new table without producing errors
 *
 * @param $variables
 *
 * @return
 */
function gmod_dbsf_install_dbtable($variables) {
  $table_name = $variables['table_name'];
  $spec       = $variables['spec'];
  $user       = $variables['user'];
  if (empty($table_name) || empty($spec)) {
    return FALSE;
  }
  $sql_create = "CREATE TABLE $table_name ($spec)";
  if (!empty($user)) {
    $sql_grant = "GRANT SELECT on $table_name to $user";
  }
  $exists = db_table_exists($table_name);
  if (empty($exists)) {
    db_query($sql_create);
    db_query($sql_grant);
    $exists = db_table_exists($table_name);
    if (empty($exists)) {
      drupal_set_message(t('Failed to create %table_name.', array('%table_name' => $table_name)), 'error');
    }
    else {
      drupal_set_message(t('Table %table_name created in your database.', array('%table_name' => $table_name)), 'warning');
    }
  }
}

/**
 * Store a feature in the feature table
 *
 * Allows for organism data to be in a second database (it syncs them)
 * Uses the est2assembly model (which does not use Parent but a placeholder; this should be changed
 * in the next version)
 * orf == orf_0 placeholder (no seq)
 * pep == pep_0 placeholder (no seq)
 * Further it uses the est2assembly multi-reference data model for featureloc:
 * contig -> contig
 * orf -> orf
 * pep -> pep
 * con -> orf_0 (not orf)
 * orf -> pep_0 (not pep)
 *
 * @param $data
 *  is an assoc. array with the following keys
 *  - pgdb: settings.ini postgres database name to store this feature.
 *  - uniquename: the internal est2assembly name. Required.
 *  - name: an alias given by the user. Optional.
 *  - organism_id: relates to the organism table. Required.
 *  - organism_db: settings.ini postgres database name which hold data on your organism.
 *    Defaults to default. It checks if it is the same as pgdb and if not
 *    then it translates the organism data.
 *  - residues: the sequence of the feature. Optional.
 *  - type: The name or ID FROM the cvterm. Becomes type_id. Required.
 *  - parent: associative array with following keys: 'parent_id','start','end','phase','strand'
 *  @return
 *  FALSE on failure. EXISTS on feature already existing
 */
function gmod_dbsf_store_feature($data) {
  $pgdb        = $data['pgdb'];
  $seq         = $data['residues'];
  $seq_length  = !empty($seq) ? strlen($seq) : $data['length'];
  $md5         = !empty($seq) ? md5($seq) : NULL;
  $uniquename  = $data['uniquename'];
  $name        = $data['name'];
  $organism_id = $data['organism_id'];
  $org_db      = !empty($data['organism_db']) ? $data['organism_db'] : 'default';
  // either ID or name
  $type             = $data['type'];
  $type_name        = $data['type_name'];
  $type_id          = $data['type_id'];
  $timeaccessioned  = $data['timeaccessioned'];
  $timelastmodified = $data['timelastmodified'];
  $parent_data      = $data['parent'];
  $analysis_data    = $data['analysis'];
  $org_pgtype       = 'chado';
  $feat_pgtype      = 'chado';
  $action           = $data['add_history']['action'];
  $actor            = $data['add_history']['actor'];
  // ISO 8601 date
  $time = date('c');

  if (strpos($org_db, 'chado') === FALSE) {
    $org_pgtype = 'drupal';
  }
  else {
    $org_pgtype = 'chado';
  }
  if (strpos($pgdb, 'chado') === FALSE) {
    $feat_pgtype = 'drupal';
  }
  else {
    $feat_pgtype = 'chado';
  }
  if (empty($pgdb) || empty($uniquename) || empty($organism_id) || (empty($type) && empty($type_id) && empty($type_name))) {
    drupal_set_message(t('Your feature %uniquename was not stored, not enough information was provided.', array('%uniquename' => $uniquename)), 'error');
    return FALSE;
  }
  //cv select
  if ($feat_pgtype == 'drupal') {
    $cvterm_name_select_sql = "SELECT name FROM {gmod_dbsf_cv} as cv WHERE cvterm_id=%d";
  }
  else {
    $cvterm_name_select_sql = "SELECT name FROM cv WHERE cvterm_id=%d";
  }

  //$type_name takes precedence over type_id (e.g. if type_id is taken FROM the wrong database)
  if (!empty($type_name)) {
    db_set_active($pgdb);
    $type_id = gmod_dbsf_get_add_cv_withnames('sequence', $type_name);
    db_set_active();
  }
  if (empty($type_id) && !empty($type)) {
    if (is_numeric($type)) {
      $type_id = $type;
      db_set_active($pgdb);
      $type_name = db_fetch_array(db_query($cvterm_name_select_sql, $type_id));
      db_set_active();
    }
    else {
      db_set_active($pgdb);
      $type_name = $type;
      $type_id = gmod_dbsf_get_add_cv_withnames('sequence', $type_name);
      db_set_active();
    }
  }
  if (empty($type_id)) {
    drupal_set_message(t('Your feature %uniquename was not stored, could not find requested CV for feature type (%type,%type_name).', array('%type' => $type, '%type_name' => $type_name, '%uniquename' => $uniquename)), 'error');
    return FALSE;
  }
  // this is the org_id FROM current database
  $current_org = 0;
  if ($org_db == $pgdb) {
    $current_org = $organism_id;
  }
  else {
    $org_data = gmod_dbsf_db_execute($org_db, 'gmod_dbsf_get_add_organism', array('organism_id' => $organism_id, 'pgtype' => $org_pgtype));
    $current_org = gmod_dbsf_db_execute($pgdb, 'gmod_dbsf_get_add_organism', $org_data + array('pgtype' => $feat_pgtype));
    if (!is_numeric($current_org)) {
      $current_org = $current_org['organism_id'];
    }
  }
  if (empty($current_org)) {
    drupal_set_message(t('Your feature %uniquename was not stored, could not sync organism data.', array('%uniquename' => $uniquename)), 'error');
    return FALSE;
  }
  if (empty($name)) {
    $name = $uniquename;
  }
  $sql_check = '';
  $sql_insert = '';
  $sql_update = '';
  $sql_parent_check = '';
  $sql_parent_get_next_rank = '';
  $sql_parent_insert = '';
  if ($feat_pgtype == 'drupal') {
    $sql_check = "SELECT feature_id FROM {gmod_dbsf_feature} as feature WHERE uniquename='%s'";
    $sql_insert = 'INSERT INTO {gmod_dbsf_feature} (uniquename,name,organism_id,residues,md5checksum,type_id) VALUES (' . "'%s','%s','%d','%s','%s',%d" . ')';
    $sql_update = "UPDATE {gmod_dbsf_feature} set %s='%s' WHERE feature_id=%d";
    $sql_parent_check = "SELECT featureloc_id FROM {gmod_dbsf_featureloc} as featureloc WHERE feature_id=%d AND srcfeature_id=(SELECT feature_id FROM {gmod_dbsf_feature} as feature WHERE uniquename='%s')";
    $sql_parent_get_next_rank = "SELECT max(rank)+1 as next_rank FROM {gmod_dbsf_featureloc} as featureloc WHERE feature_id=%d";
    $sql_parent_insert = "INSERT INTO {gmod_dbsf_featureloc} (feature_id,srcfeature_id,fmin,fmax,phase,strand,rank) VALUES " . "(%d,(SELECT feature_id FROM {gmod_dbsf_feature} as feature WHERE uniquename='%s'),%d,%d,%d,%d,%d)";
    if (is_numeric($parent_data['parent_id'])) {
      $sql_parent_check = "SELECT featureloc_id FROM {gmod_dbsf_featureloc} as featureloc WHERE feature_id=%d AND srcfeature_id=%d";
      $sql_parent_insert = "INSERT INTO {gmod_dbsf_featureloc} (feature_id,srcfeature_id,fmin,fmax,phase,strand,rank) VALUES " . "(%d,%d,%d,%d,%d,%d,%d)";
    }
  }
  else {
    $sql_check = "SELECT feature_id FROM feature WHERE uniquename='%s'";
    $sql_insert = 'INSERT INTO feature (uniquename,name,organism_id,residues,md5checksum,type_id) VALUES (' . "'%s','%s','%d','%s','%s',%d" . ')';
    $sql_update = "UPDATE feature set %s='%s' WHERE feature_id=%d";
    $sql_parent_check = "SELECT featureloc_id FROM featureloc WHERE feature_id=%d AND srcfeature_id=(SELECT feature_id FROM feature WHERE uniquename='%s')";
    $sql_parent_get_next_rank = "SELECT max(rank)+1 as next_rank FROM featureloc WHERE feature_id=%d";
    $sql_parent_insert = "INSERT INTO featureloc (feature_id,srcfeature_id,fmin,fmax,phase,strand,rank) VALUES " . "(%d,(SELECT feature_id FROM feature WHERE uniquename='%s'),%d,%d,%d,%d,%d)";
    if (is_numeric($parent_data['parent_id'])) {
      $sql_parent_check = "SELECT featureloc_id FROM featureloc WHERE feature_id=%d AND srcfeature_id=%d";
      $sql_parent_insert = "INSERT INTO featureloc (feature_id,srcfeature_id,fmin,fmax,phase,strand,rank) VALUES " . "(%d,%d,%d,%d,%d,%d,%d)";
    }
  }

  gmod_dbsf_db_execute($pgdb);
  $check = db_fetch_array(db_query($sql_check, $uniquename));
  $feature_id = $check['feature_id'];
  if (!empty($feature_id)) {
    //already exists
    /*$placeholder_id=0;
    if (!empty($type_name) && ($type_name!='mRNA' || $type_name!='contig' )){
    db_query($sql_insert,$uniquename.'_0','placeholder for ',$name,$current_org,NULL,NULL,$type_id);
    $placeholder_check=db_fetch_array(db_query($sql_check,$uniquename.'_0'));
    $placeholder_id= $placeholder_check['feature_id'];
    }*/


    if (!empty($parent_data)) {
      //TODO also see gmod_dbsf_link_unlink_features
      $daughter_check = db_fetch_array(db_query($sql_parent_check, $feature_id, $parent_data['parent_id']));
      if (empty($daughter_check)) {
        $rank = db_fetch_array(db_query($sql_parent_get_next_rank, $feature_id));
        $next_rank = !empty($rank['next_rank']) ? $rank['next_rank'] : 0;
        //fmin is interbase coordinate starting FROM 0, so -1
        $fmin = !empty($parent_data['start']) ? $parent_data['start'] - 1 : 0;
        $fmax = !empty($parent_data['end']) ? $parent_data['end'] : 0;
        db_query($sql_parent_insert, $feature_id, $parent_data['parent_id'], $fmin, $fmax, $parent_data['phase'], $parent_data['strand'], $next_rank);
        //db_query($sql_parent_insert,$feature_id,$placeholder_id,0,$seq_length,'','+',0);
        $daughter_check = db_fetch_array(db_query($sql_parent_check, $feature_id, $parent_data['parent_id']));
        if (empty($daughter_check)) {
          gmod_dbsf_db_execute();
          drupal_set_message(t('Failed to link your feature %uniquename with its parent (%p). Perhaps you have not requested the parent to be added?' . ' Perhaps a permissions error, contact the administrator citing %feature_id.', array('%uniquename' => $uniquename, '%p' => $parent_data['parent_id'], '%feature_id' => $feature_id)
          ), 'error');
          return FALSE;
          gmod_dbsf_db_execute($pgdb);
        }
      }
    }
    if (!empty($timelastmodified)) {
      db_query($sql_update, 'timelastmodified', $timelastmodified, $feature_id);
    }
    if (!empty($timeaccessioned)) {
      db_query($sql_update, 'timeaccessioned', $timeaccessioned, $feature_id);
    }
    if (!empty($seq)) {
      db_query($sql_update, 'residues', $seq, $feature_id);
    }
    if (!empty($action) && !empty($actor)) {
      $update_cvterm_id = gmod_dbsf_get_add_cv_withnames('curator_actions', $action);
      //person, time one after the other
      gmod_dbsf_populate_prop('feature', $feature_id, $update_cvterm_id, $actor);
      gmod_dbsf_populate_prop('feature', $feature_id, $update_cvterm_id, $time);
    }
    gmod_dbsf_db_execute();
    return $feature_id;
  }
  else {
    //add it
    db_query($sql_insert, $uniquename, $name, $current_org, $seq, $md5, $type_id);
    //check main
    $check = db_fetch_array(db_query($sql_check, $uniquename));
    $feature_id = $check['feature_id'];
    // add placeholder if needed
    /*$placeholder_id=0;
    if (!empty($type_name) && ($type_name!='mRNA' || $type_name!='contig' )){
    db_query($sql_insert,$uniquename.'_0','placeholder for '.$name,$current_org,NULL,NULL,$type_id);
    $placeholder_check=db_fetch_array(db_query($sql_check,$uniquename.'_0'));
    $placeholder_id= $placeholder_check['feature_id'];
    }*/


    if (!empty($feature_id)) {
      if (!empty($parent_data['parent_id'])) {
        $daughter_check = db_fetch_array(db_query($sql_parent_check, $feature_id, $parent_data['parent_id']));
        if (empty($daughter_check)) {
          $rank      = db_fetch_array(db_query($sql_parent_get_next_rank, $feature_id));
          $next_rank = !empty($rank['next_rank']) ? $rank['next_rank'] : 0;
          $fmin      = !empty($parent_data['start']) ? $parent_data['start'] - 1 : 0;
          $fmax      = !empty($parent_data['end']) ? $parent_data['end'] : 0;
          db_query($sql_parent_insert, $feature_id, $parent_data['parent_id'], $fmin, $fmax, $parent_data['phase'], $parent_data['strand'], $next_rank);
          //db_query($sql_parent_insert,$feature_id,$placeholder_id,0,$seq_length,'','+',0);
          $daughter_check = db_fetch_array(db_query($sql_parent_check, $feature_id, $parent_data['parent_id']));
          if (empty($daughter_check)) {
            gmod_dbsf_db_execute();
            drupal_set_message(t('Failed to link your feature %uniquename with its parent (%p). ' . 'Perhaps you have not requested the parent to be added? Perhaps a permissions error, contact the administrator citing %feature_id.',
            array('%uniquename' => $uniquename, '%p' => $parent_data['parent_id'], '%feature_id' => $feature_id)
            )
            , 'error'
            );
            return FALSE;
            gmod_dbsf_db_execute($pgdb);
          }
        }
      }
      if (!empty($timelastmodified)) {
        db_query($sql_update, 'timelastmodified', $timelastmodified, $feature_id);
      }
      if (!empty($timeaccessioned)) {
        db_query($sql_update, 'timeaccessioned', $timeaccessioned, $feature_id);
      }
      gmod_dbsf_db_execute();
      if (!empty($action) && !empty($actor)) {
        $update_cvterm_id = gmod_dbsf_get_add_cv_withnames('curator_actions', $action);
        // person, time one after the other
        gmod_dbsf_populate_prop('feature', $feature_id, $update_cvterm_id, $actor);
        gmod_dbsf_populate_prop('feature', $feature_id, $update_cvterm_id, $time);
      }
      return $feature_id;
    }
    else {
      gmod_dbsf_db_execute();
      drupal_set_message(t('Failed to insert your feature %uniquename at %pgdb. Perhaps a permissions error, contact the administrator.', array('%uniquename' => $uniquename, '%pgdb' => $pgdb)), 'error');
      return FALSE;
    }
  }
}

/**
 * Get or add data for an organism
 *
 * Uses the chado organism schema instead of the gmod_dbsf
 *
 * @param $data
 * if $data['organism_id'] is present, then it is an organism id
 *  and we we want to get the data for it.
 * Otherwise, we want to store the data and return the new organism_id.
 * The $data['pgtype'] can be either drupal or chado (case sensitive). This
 * regulates which schema is being used
 *
 * @return
 * FALSE on failure, TRUE on adding success or an associative array with the columns as keys
 * if you wanted to fetch.
 */
function gmod_dbsf_get_add_organism($data) {
  if (empty($data)) {
    return;
  }
  $org_id       = $data['organism_id'];
  $pgtype       = !empty($data['pgtype']) ? $data['pgtype'] : 'drupal';
  $update       = $data['update'];
  $genus        = $data['genus'];
  $species      = $data['species'];
  $common_name  = $data['common_name'];
  $tax_class    = $data['class'];
  $tax_family   = $data['family'];
  $tax_order    = $data['order'];
  $ncbi_id      = $data['ncbi_taxid'];
  $binomial     = $data['binomial'];
  $abbreviation = substr($genus, 0, 1) .'.'. $species;
  // all sqls (must) have one row
  $sql_check_org_prop = '';
  $sql_insert_org_prop = '';
  $sql_check_org_dbxref = '';
  $sql_insert_org_dbxref = '';
  $sql_check = "SELECT organism_id as id FROM {gmod_dbsf_organism} as organism WHERE genus='%s' AND species='%s' ORDER BY ncbi_taxid DESC";
  $sql_select_org = "SELECT organism_id,tax_class as class,tax_order as order,tax_family as family,genus,species, ncbi_taxid,common_name" . " FROM {gmod_dbsf_organism} as organism WHERE organism_id=%d ORDER BY ncbi_taxid DESC";
  $sql_insert_org = "INSERT INTO {gmod_dbsf_organism} (tax_class,tax_order,tax_family,genus,species, ncbi_taxid,common_name,abbreviation)" . " VALUES ('%s','%s','%s','%s','%s','%s','%s','%s')";

  if ($pgtype == 'chado') {
    $sql_check = "SELECT organism_id as id FROM organism WHERE genus='%s' AND species='%s'";
    $sql_check_org_dbxref = "SELECT dbxref_id as id FROM organism_dbxref WHERE organism_id=%d AND dbxref_id=%d";
    $sql_insert_org_dbxref = "INSERT INTO organism_dbxref (organism_id,dbxref_id) VALUES (%d,%d)";
    $sql_check_org_prop = "SELECT organismprop_id as id FROM organismprop WHERE organism_id=%d AND value='%s' AND type_id=" . "(SELECT cvterm_id FROM cvterm WHERE cv_id=(SELECT cv_id FROM cv WHERE name='NCBI_TAXONOMY_RANKS') AND name='%s')";
    $sql_insert_org_prop = "INSERT INTO organismprop (organism_id,value,type_id) VALUES (" . "%d,'%s',(SELECT cvterm_id FROM cvterm WHERE cv_id=(SELECT cv_id FROM cv WHERE name='NCBI_TAXONOMY_RANKS') AND name='%s'))";
    $sql_select_org = "select organism.organism_id, " . "(select organismprop.value FROM organismprop join cvterm ON organismprop.type_id=cvterm.cvterm_id WHERE organismprop.organism_id=%d AND cvterm.cv_id=(select cv_id FROM cv WHERE name='NCBI_TAXONOMY_RANKS') AND cvterm.name IN ('class') ) as class," . "(select organismprop.value  FROM organismprop join cvterm ON organismprop.type_id=cvterm.cvterm_id WHERE organismprop.organism_id=%d AND cvterm.cv_id=(select cv_id FROM cv WHERE name='NCBI_TAXONOMY_RANKS') AND cvterm.name IN ('order') ) as order," . "(select organismprop.value  FROM organismprop join cvterm ON organismprop.type_id=cvterm.cvterm_id WHERE organismprop.organism_id=%d AND cvterm.cv_id=(select cv_id FROM cv WHERE name='NCBI_TAXONOMY_RANKS') AND cvterm.name IN ('family') ) as family," . "genus,species,common_name,dbxref.accession as ncbi_taxid,dbxref.description FROM organism join organism_dbxref ON organism.organism_id=organism_dbxref.organism_id JOIN dbxref ON organism_dbxref.dbxref_id = dbxref.dbxref_id WHERE organism.organism_id=%d";
    $sql_insert_org = "INSERT INTO organism (genus,species,common_name,abbreviation) " . " VALUES ('%s','%s','%s','%s')";
  }


  //get
  if (!empty($org_id) && empty($genus) && empty($update)) {
    $new_data = array();
    //get data if it exists
    $new_data = db_fetch_array(db_query($sql_select_org, $org_id, $org_id, $org_id, $org_id));
    if (!empty($new_data)) {
      return $new_data;
    }
    else {
      return FALSE;
    }
  }
  //add
  elseif (empty($update) && !empty($genus)) {
    if (empty($genus) || empty($species)) {
      //dvm('Not enough data provided to store a new organism.');
      return FALSE;
    }
    //store  data AND get org_id
    if ($pgtype == 'chado') {

      //org
      $check = db_fetch_array(db_query($sql_check, $genus, $species));
      if (empty($check['id'])) {
        db_query($sql_insert_org, $genus, $species, $common_name, $abbreviation);
        $check = db_fetch_array(db_query($sql_check, $genus, $species));
        if (empty($check['id'])) {
          drupal_set_message(t('Failed to insert new organism.'), 'error');
          return FALSE;
        }
      }
      $org_id = $check['id'];
      //dbxref/ncbi_taxid
      $dbxref_id = gmod_dbsf_get_add_dbxref_withnames('NCBI_TAXONOMY', $ncbi_id, $genus .' '. $species);
      if (empty($dbxref_id)) {
        drupal_set_message(t('Cannot add new NCBI tax id.'), 'error');
        return FALSE;
      }
      $dbxref_check = db_fetch_array(db_query($sql_check_org_dbxref, $org_id, $dbxref_id));
      if (empty($dbxref_check['id'])) {
        db_query($sql_insert_org_dbxref, $org_id, $dbxref_id);
      }
      $org_check = db_fetch_array(db_query($sql_check_org_prop, $org_id, $tax_class, 'class'));
      if (empty($org_check['id'])) {
        db_query($sql_insert_org_prop, $org_id, $tax_class, 'class');
      }
      $org_check = db_fetch_array(db_query($sql_check_org_prop, $org_id, $tax_order, 'order'));
      if (empty($org_check['id'])) {
        db_query($sql_insert_org_prop, $org_id, $tax_order, 'order');
      }
      $org_check = db_fetch_array(db_query($sql_check_org_prop, $org_id, $tax_family, 'family'));
      if (empty($org_check['id'])) {
        db_query($sql_insert_org_prop, $org_id, $tax_family, 'family');
      }

      $new_data = db_fetch_array(db_query($sql_select_org, $org_id, $org_id, $org_id, $org_id));
    }
    else {
      $check = db_fetch_array(db_query($sql_check, $genus, $species));
      if (empty($check['id'])) {
        db_query($sql_insert_org, $tax_class, $tax_order, $tax_family, $genus, $species, $ncbi_id, $common_name, $abbreviation);
        $check = db_fetch_array(db_query($sql_check, $genus, $species));
        if (empty($check['id'])) {
          drupal_set_message(t('Failed to insert new organism.'), 'error');
          return FALSE;
        }
      }
      $org_id = $check['id'];
      $new_data = db_fetch_array(db_query($sql_select_org, $org_id));
    }

    if (empty($new_data['class']) || empty($new_data['order']) || empty($new_data['family'])
    || empty($new_data['ncbi_taxid'])){
      drupal_set_message(t('Could not add new organism data. Mayabe because the db has duplicate data or I could not fetch the complete phylogeny.'), 'error', FALSE);
      return FALSE;
    }
    return $org_id;
  }
  //update
  elseif ($update === TRUE) {
    $sql_update = '';
    $sql_check = '';
    if ($pgtype == 'chado') {
      $sql_update = "UPDATE organism set %s='%s' WHERE organism_id=$org_id";
      $sql_check = "SELECT %s as check FROM organism WHERE organism_id=$org_id AND %s='%s'";
    }
    else {
      $sql_update = "UPDATE {gmod_dbsf_organism} set %s='%s' WHERE organism_id=$org_id";
      $sql_check = "SELECT %s as check FROM {gmod_dbsf_organism} as organism WHERE organism_id=$org_id AND %s='%s'";
    }
    if (!empty($common_name)) {
      db_query($sql_update, 'common_name', $common_name);
      $check = db_fetch_array(db_query($sql_check, 'common_name', 'common_name', $common_name));
      if (!empty($check['check'])) {
        drupal_set_message(t('Common name changed to %common_name.', array('%common_name' => $common_name)), 'warning');
      }
      else {
        drupal_set_message(t('Failed to change common name to %common_name. Perhaps a permissions error?',
        array('%common_name' => $common_name)
        ), 'error');
      }
    }
  }
}

/**
 * Save an array to be used for the batch API.
 * see batch_set()
 *
 * @param $data
 *   A variable to store to $context
 * @param $context
 *   The variable used by batch API to store data
 */
function gmod_dbsf_batch_save_data($data = NULL, &$context) {
  $context['results']['data'] = $data;
}

/**
 * Upload FASTA as used in a batch operation.
 *
 * Needed because we use the same create_fasta function more than once
 * @see gmod_dbsf_write_fastafile()
 * @see dbsf_formatdb_fastafile()
 *
 * @param $batch_file_data
 *   Associative array with following keys.
 *   - infile: all the infiles to be passed to gmod_dbsf_write_fastafile()
 *   - outfile: likewise, all outfiles
 *   - filetype: likewise all file types
 *   - format: whether to run format this file via dbsf_formatdb_fastafile()
 * @param $context
 *   Array FROM batch_api
 *
 * @return
 *   It does not return anything, it updates $context instead by altering
 *   $context['finished']
 */
function gmod_dbsf_batch_upload_fasta($batch_file_data, &$context) {
  $uniquename_list = $batch_file_data['name'];
  $infilelist      = $batch_file_data['infile'];
  $outfilelist     = $batch_file_data['outfile'];
  $filetype        = $batch_file_data['filetype'];
  $formatlist      = $batch_file_data['format'];
  if (empty($infilelist) || empty($outfilelist) ||
  empty($filetype) || empty($formatlist)
  ) {
    return FALSE;
  }
  $max = count($infilelist);
  $progress = 0;
  foreach ($infilelist as $uid => $infile) {
    if (empty($infile)) {
      $progress++;
      continue;
    }
    gmod_dbsf_write_fastafile($infile, $outfilelist[$uid], TRUE, $uniquename_list[$uid]);
    if ($formatlist[$uid] === TRUE) {
      // I/O friendship?
      sleep(1);
      biosoftware_bench_formatdb_fastafile($outfilelist[$uid], $filetype[$uid]);
      $context['results'][$uid]['subject'][] = basename($outfilelist[$uid]);
    }
    $progress++;
  }
  $context['finished'] = $progress / $max;
}

/**
 * Create parameter file for daemon
 *
 * @param $uid
 *   A unique identifier
 * @param $dir
 *   Directory of WHERE to create the file
 * @param $par
 *   Contents to print, such as the parameters to be used by the software. This can now be an array
 * @param $software
 *   Name of software used
 * @param $more_data
 *   A string or array with any other data which should be written. If it is an
 *   associative array, the data are printed as $key : $value
 *
 * @return
 *   TRUE on success..
 */
function gmod_dbsf_parameter_daemon($uid, $dir, $par, $software = 'blastall', $more_data = NULL, $cmd_vars = NULL) {
  if (empty($uid) || empty($dir) || empty($par)) {
    return FALSE;
  }
  // need to print uid, software, par and condor. No spaces.
  $data = "uid:$uid\nsoftware:$software\n";

  if (!empty($more_data)) {
    if (is_array($more_data)) {
      foreach ($more_data as $key => $value) {
        if (is_array($value)) {
          foreach ($value as $element) {
            if (!empty($element)) {
              $data .= $key .':'. $element ."\n";
            }
          }
        }
        else {
          if (!empty($value)) {
            $data .= $key .':'. $value ."\n";
          }
        }
      }
    }
    else {
      $data .= $more_data ."\n";
    }
  }
  // allows multiple blasts to run FROM same wait file
  if (is_array($par)) {
    $i = 0;
    foreach ($par as $par_data) {
      $i++;
      if (!empty($cmd_vars)) {
        $data .= "par:$par_data ";
        if (!empty($cmd_vars['in'])) {
          $data .= ' '. $cmd_vars['in'];
        }
        else {
          $data .= ' -i';
        }
        $data .= " $uid.query ";
        if (!empty($cmd_vars['out'])) {
          $data .= ' '. $cmd_vars['out'];
        }
        else {
          $data .= ' -o';
        }
        $data .= " $uid.$software.$i.output\n";
      }
      else {
        $data .= "par:$par_data -i $uid.query -o $uid.$software.$i.output\n";
      }
    }
  }
  else {
    if (!empty($cmd_vars)) {
      $data .= "par:$par ";
      if (!empty($cmd_vars['in'])) {
        $data .= ' '. $cmd_vars['in'];
      }
      else {
        $data .= ' -i';
      }
      $data .= " $uid.query ";
      if (!empty($cmd_vars['out'])) {
        $data .= ' '. $cmd_vars['out'];
      }
      else {
        $data .= ' -o';
      }
      $data .= " $uid.$software.output\n";
    }
    else {
      $data .= "par:$par -i $uid.query -o $uid.$software.output\n";
    }
  }
  $outfile = $dir .'/'. $uid .".$software.wait";
  if (!$outhandle = fopen($outfile, 'wt')) {
    drupal_set_message(t('Could not create %outfile.', array('%outfile' => $outfile)), 'error');
    return FALSE;
  }
  fwrite($outhandle, $data);
  fclose($outhandle);
  return TRUE;
}

/**
 * Translate a DNA to a protein sequence
 *
 * Borrowed FROM the biophp project
 *
 * @param $seq
 * The Sequence to translate as a string
 * @param $genetic_code
 * An integer for the genetic code which defines the codon table to use.
 * - 1 => Standard
 * - 2 => Vertebrate Mitochondrial
 * - 3 => Yeast Mitochondrial
 * - 4 => Mold, Protozoan and Coelenterate Mitochondrial. Mycoplasma, Spiroplasma
 * - 5 => Invertebrate Mitochondrial
 * - 6 => Ciliate Nuclear; Dasycladacean Nuclear; Hexamita Nuclear
 * - 9 => Echinoderm Mitochondrial
 * - 10 => Euplotid Nuclear
 * - 11 => Bacterial and Plant Plastid
 * - 12 => Alternative Yeast Nuclear
 * - 13 => Ascidian Mitochondrial
 * - 14 => Flatworm Mitochondrial
 * - 15 => Blepharisma Macronuclear
 * - 16 => Chlorophycean Mitochondrial
 * - 21 => Trematode Mitochondrial
 * - 22 => Scenedesmus obliquus mitochondrial
 * - 23 => Thraustochytrium mitochondrial code
 *
 * @return string
 * of the protein sequence
 */
function gmod_dbsf_translate_DNA_to_protein($seq, $genetic_code) {
  if (empty($seq) || empty($genetic_code)) {
    return FALSE;
  }
  // From biophp.org
  $aminoacids = array("F", "L", "I", "M", "V", "S", "P", "T", "A", "Y", "*", "H", "Q", "N", "K", "D", "E", "C", "W", "R", "G", "X");
  // Standard genetic code
  $triplets[1] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AGT |AGC )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TAG |TGA )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG )", "(CG. |AGA |AGG )", "(GG. )", "(\S\S\S )",
  );
  // Vertebrate Mitochondrial
  $triplets[2] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AGT |AGC )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TAG |AGA |AGG )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG |TGA )", "(CG. )", "(GG. )", "(\S\S\S )",
  );
  // Yeast Mitochondrial
  $triplets[3] = array("(TTT |TTC )", "(TTA |TTG )", "(ATT |ATC )", "(ATG |ATA )", "(GT. )", "(TC. |AGT |AGC )",
    "(CC. )", "(AC. |CT. )", "(GC. )", "(TAT |TAC )", "(TAA |TAG )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG |TGA )", "(CG. |AGA |AGG )", "(GG. )", "(\S\S\S )",
  );
  // Mold, Protozoan and Coelenterate Mitochondrial. Mycoplasma, Spiroplasma
  $triplets[4] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AGT |AGC )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TAG )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG |TGA )", "(CG. |AGA |AGG )", "(GG. )", "(\S\S\S )",
  );
  // Invertebrate Mitochondrial
  $triplets[5] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC )", "(ATG |ATA )", "(GT. )", "(TC. |AG. )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TAG )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG |TGA )", "(CG. )", "(GG. )", "(\S\S\S )",
  );
  // Ciliate Nuclear; Dasycladacean Nuclear; Hexamita Nuclear
  $triplets[6] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AGT |AGC )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TGA )", "(CAT |CAC )",
    "(CAA |CAG |TAA |TAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG )", "(CG. |AGA |AGG )", "(GG. )", "(\S\S\S )",
  );
  // Echinoderm Mitochondrial
  $triplets[9] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AG. )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TAG )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAA |AAT |AAC )", "(AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG |TGA )", "(CG. )", "(GG. )", "(\S\S\S )",
  );
  // Euplotid Nuclear
  $triplets[10] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AGT |AGC )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TAG )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC |TGA )",
    "(TGG )", "(CG. |AGA |AGG )", "(GG. )", "(\S\S\S )",
  );
  // Bacterial and Plant Plastid
  $triplets[11] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AGT |AGC )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TAG |TGA )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG )", "(CG. |AGA |AGG )", "(GG. )", "(\S\S\S )",
  );
  // Alternative Yeast Nuclear
  $triplets[12] = array("(TTT |TTC )", "(TTA |TTG |CTA |CTT |CTC )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AGT |AGC |CTG )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TAG |TGA )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG )", "(CG. |AGA |AGG )", "(GG. )", "(\S\S\S )",
  );
  // Ascidian Mitochondrial
  $triplets[13] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC )", "(ATG |ATA )", "(GT. )", "(TC. |AGT |AGC )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TAG )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG |TGA )", "(CG. )", "(GG. |AGA |AGG )", "(\S\S\S )",
  );
  // Flatworm Mitochondrial
  $triplets[14] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AG. )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC |TAA )", "(TAG )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC |AAA )", "(AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG |TGA )", "(CG. )", "(GG. )", "(\S\S\S )",
  );
  // Blepharisma Macronuclear
  $triplets[15] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AGT |AGC )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TGA )", "(CAT |CAC )",
    "(CAA |CAG |TAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG )", "(CG. |AGA |AGG )", "(GG. )", "(\S\S\S )",
  );
  // Chlorophycean Mitochondrial
  $triplets[16] = array("(TTT |TTC )", "(TTA |TTG |CT. |TAG )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AGT |AGC )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TGA )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG )", "(CG. |AGA |AGG )", "(GG. )", "(\S\S\S )",
  );
  // Trematode Mitochondrial
  $triplets[21] = array("(TTT |TTC )", "(TTA |TTG |CT. )", "(ATT |ATC )", "(ATG |ATA )", "(GT. )", "(TC. |AG. )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TAG )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC |AAA )", "(AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG |TGA )", "(CG. )", "(GG. )", "(\S\S\S )",
  );
  // Scenedesmus obliquus mitochondrial
  $triplets[22] = array("(TTT |TTC )", "(TTA |TTG |CT. |TAG )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TCT |TCC |TCG |AGT |AGC )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TAA |TGA |TCA )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG )", "(CG. |AGA |AGG )", "(GG. )", "(\S\S\S )",
  );
  // Thraustochytrium mitochondrial code
  $triplets[23] = array("(TTT |TTC )", "(TTG |CT. )", "(ATT |ATC |ATA )", "(ATG )", "(GT. )", "(TC. |AGT |AGC )",
    "(CC. )", "(AC. )", "(GC. )", "(TAT |TAC )", "(TTA |TAA |TAG |TGA )", "(CAT |CAC )",
    "(CAA |CAG )", "(AAT |AAC )", "(AAA |AAG )", "(GAT |GAC )", "(GAA |GAG )", "(TGT |TGC )",
    "(TGG )", "(CG. |AGA |AGG )", "(GG. )", "(\S\S\S )",
  );

  // place a space after each triplete in the sequence
  $temp = chunk_split($seq, 3, ' ');

  // replace triplets by corresponding amnoacid
  $peptide = preg_replace($triplets[$genetic_code], $aminoacids, $temp);

  // return peptide sequence
  return $peptide;
}

/**
 * Get or add library data
 *
 * under-construction
 * Chado Libraries have a type_id/cvterm.name, a name and a uniquename
 * In est2assembly, the name is the friendly name aimed for users. The uniquename varies:
 * if the library is derived FROM dbest, then the name is accession of the dbest. We also add
 * the accession in library_dbxref.
 * Otherwise, we have chosen a uniquename ourselves. If adding, then it must be verified as unique
 * before continuing.
 *
 * @param $data
 * If empty, return ID, type and name of all libraries user has access to.
 * @param $op
 * Type of operation. If set to 'select_options' then flattened array of ID=>name is returned.
 * Otherwise, returns an associative array with the keys org_abbr, organism_id, type_id, cvterm.name, library.name
 *
 * @return array
 * An associative array with the keys org_abbr, organism_id, type_id, cvterm.name, library.name
 * or a flattened array of ID => name if $op = 'select_options'
 */
function gmod_dbsf_get_add_library($data = NULL,$op=NULL) {
  $is_chado     = gmod_dbsf_is_chado();
  if (empty($data)) {
    //return all data
    $return_array = array();
    $sql_select   = '';
    if ($is_chado === FALSE) {
      $sql_select = "SELECT organism.abbreviation as org_abbr,library_id,type_id,cvterm.name as type_name,library.name as lib_name,library.organism_id FROM "
      . " {gmod_dbsf_library} as library join {gmod_dbsf_cvterm} as cvterm on library.type_id=cvterm.cvterm_id JOIN {gmod_dbsf_organism} as organism ON organism.organism_id=library.organism_id "
      . " ORDER by org_abbr,lib_name";
    }
    else {
      $sql_select = "SELECT organism.abbreviation as org_abbr,library_id,type_id,cvterm.name as type_name,library.name as lib_name,library.organism_id FROM "
      . " library join cvterm on library.type_id=cvterm.cvterm_id JOIN organism ON organism.organism_id=library.organism_id "
      . " ORDER by org_abbr,lib_name";
    }
    $db_data = db_query($sql_select);
    while ($row = db_fetch_array($db_data)) {
      $access = gmod_dbsf_chadoapi_check_restriction('select', 'library', $row['library_id'], FALSE);
      if ($access == TRUE) {
        $name = $row['lib_name'];
        if (strlen($name) > 85) {
          $name = substr($name, 0, 80) .' ...';
        }
        if ($op == 'select_options'){
          $return_array[$row['library_id']]  = $name;
        }else{
          $return_array[$row['library_id']] = array('org_abbr' => $row['org_abbr'],
          	'organism_id' => $row['organism_id'], 'type_id' => $row['type_id'], 'cvterm.name' => $row['type_name'], 'library.name' => $name,
          );
        }
      }
    }
    return $return_array;
  }
  $library_id  = $data['library_id'];
  $pgtype      = 'chado';
  $update      = $data['update'];
  $name        = $data['name'];
  $type_id     = $data['type_id'];
  $organism_id = $data['organism_id'];
  $uniquename  = $data['uniquename'];
  $accession   = $data['accession'];
  $db_name     = $data['db_name'];

  if (!empty($type_id) && !is_numeric($type_id)) {
    $select_cvterm = '';
    if ($is_chado === FALSE) {
      $select_cvterm = "SELECT cvterm_id as id FROM {gmod_dbsf_cvterm} as cvterm WHERE name='$type_id' AND cv_id=" . "(SELECT cv_id FROM {gmod_dbsf_cv} as cv WHERE name='Library types')";
    }
    else {
      $select_cvterm = "SELECT cvterm_id as id FROM cvterm WHERE name='$type_id' AND cv_id=" . "(SELECT cv_id FROM cv WHERE name='Library types')";
    }
    $type = db_fetch_array(db_query($select_cvterm));
    $type_id = $type['id'];
  }

  // all sqls (must) have one row
  $sql_check = '';
  // has 4 variables, all $library_id
  $sql_select_library = '';
  $sql_insert_library = '';
  // Not needed, only if a db_name and accession are present.
  $sql_check_library_dbxref = '';
  $sql_insert_library_dbxref = '';
  if ($is_chado === FALSE) {
    $sql_check = "SELECT library_id as id FROM {gmod_dbsf_library} WHERE uniquename='%s'";
    $sql_select_library = "SELECT organism.abbreviation as org_abbr,library_id,type_id,cvterm.name as type_name,library.name as lib_name,library.organism_id FROM " . " {gmod_dbsf_library} as library join {gmod_dbsf_cvterm} as cvterm on library.type_id=cvterm.cvterm_id JOIN {gmod_dbsf_organism} as organism ON organism.organism_id=library.organism_id " . " WHERE library_id=%d";
    $sql_insert_library = "INSERT INTO {gmod_dbsf_library} (name,uniquename,type_id,organism_id)" . " VALUES ('%s','%s',%d,%d)";
    $sql_check_library_dbxref = "SELECT dbxref_id as id FROM {gmod_dbsf_library_dbxref} as library_dbxref WHERE library_id=%d AND dbxref_id=%d";
    $sql_insert_library_dbxref = "INSERT INTO {gmod_dbsf_library_dbxref} (library_id,dbxref_id) VALUES (%d,%d)";
  }
  else {
    $sql_check = "SELECT library_id as id FROM library WHERE uniquename='%s'";
    $sql_select_library = "SELECT organism.abbreviation as org_abbr,library_id,type_id,cvterm.name as type_name,library.name as lib_name,library.organism_id FROM " . " library join cvterm on library.type_id=cvterm.cvterm_id JOIN organism ON organism.organism_id=library.organism_id " . " WHERE library_id=%d";
    $sql_insert_library = "INSERT INTO library (name,uniquename,type_id,organism_id)" . " VALUES ('%s','%s',%d,%d)";
    $sql_check_library_dbxref = "SELECT dbxref_id as id FROM library_dbxref WHERE library_id=%d AND dbxref_id=%d";
    $sql_insert_library_dbxref = "INSERT INTO library_dbxref (library_id,dbxref_id) VALUES (%d,%d)";
  }

  //get
  if (!empty($library_id) && empty($uniquename) && empty($update)) {
    $new_data = array();
    //get data if it exists
    $new_data = db_fetch_array(db_query($sql_select_library, $library_id));

    if (!empty($new_data)) {
      return $new_data;
    }
    else {
      return FALSE;
    }
  }
  //add
  elseif (empty($update) && !empty($uniquename)) {
    if (empty($uniquename) || empty($type_id)) {
      //dvm('Not enough data provided to store a new library.');
      return FALSE;
    }
    if (empty($name)) {
      $name = $uniquename;
    }
    //store  data and get library_id
    if ($pgtype == 'chado') {

      //library
      $check = db_fetch_array(db_query($sql_check, $uniquename));
      if (empty($check['id'])) {
        db_query($sql_insert_library, $name, $uniquename, $type_id, $organism_id);
        $check = db_fetch_array(db_query($sql_check, $uniquename));
        if (empty($check['id'])) {
          drupal_set_message(t('Failed to insert new library.'), 'error');
          return FALSE;
        }
      }
      $library_id = $check['id'];
      //dbxref/ncbi_taxid
      if (!empty($accession) && !empty($db_name)) {
        $dbxref_id = gmod_dbsf_get_add_dbxref_withnames($db_name, $accession);
        if (empty($dbxref_id)) {
          drupal_set_message(t('Cannot add new %db_name ID.', array('%db_name' => $db_name)), 'error');
          return FALSE;
        }
        $dbxref_check = db_fetch_array(db_query($sql_check_library_dbxref, $library_id, $dbxref_id));
        if (empty($dbxref_check['id'])) {
          db_query($sql_insert_library_dbxref, $library_id, $dbxref_id);
        }
      }
      $new_data = db_fetch_array(db_query($sql_select_library, $library_id));
    }
    //library_id,type_id,cvterm.name as type_name,library.name as lib_name,library.organism_id
    if (empty($new_data['type_name']) || empty($new_data['lib_name'])) {
      //dvm("Could not add new library data.");
      return FALSE;
    }
    return $library_id;
  }
  //update
  elseif ($update === TRUE) {
    $sql_update = '';
    $sql_check = '';
    if ($is_chado === FALSE) {
      $sql_update = "UPDATE {gmod_dbsf_library} set %s='%s' WHERE library_id=$library_id";
      $sql_check = "SELECT %s as check FROM {gmod_dbsf_library} as library WHERE library_id=$library_id AND %s='%s'";
    }
    else {
      $sql_update = "UPDATE library set %s='%s' WHERE library_id=$library_id";
      $sql_check = "SELECT %s as check FROM library WHERE library_id=$library_id AND %s='%s'";
    }
    if (!empty($name)) {
      db_query($sql_update, 'name', $name);
      $check = db_fetch_array(db_query($sql_check, 'name', 'name', $name));
      if (!empty($check['check'])) {
        drupal_set_message(t('Property name changed to %name.', array('%name' => $name)), 'warning');
      }
      else {
        drupal_set_message(t('Failed to name to %name. Perhaps a permissions error?', array('%name' => $name)), 'error');
      }
    }
  }
}

/**
 * Get library data using an library id or binomial name
 *
 * Allows for Drupal library table which does not exist (yet)
 *
 * @param $library_id
 * The id, name, uniquename or dbEST code to get data for
 * @param $limit
 * Can be library_id, uniquename, name or dbEST in order to force
 * search only in that property
 * @param $full_access
 * Return data, even if user is not allowed. Useful to find out if a uniquename
 * is  already taken.
 *
 * @return
 * FALSE on failure or in success an associative array with
 * 'uniquename','name','library_id' as keys

 */
function gmod_dbsf_decypher_library_id($library_id, $limit = NULL, $full_access = FALSE) {
  if (empty($library_id)) {
    return FALSE;
  }

  //decide between name, uniquename and library_id
  $is_chado = gmod_dbsf_is_chado();
  $sql_select = '';

  if ($is_chado === FALSE) {
    $sql_select = "SELECT library_id,uniquename,name FROM {gmod_dbsf_library} as library WHERE %s='$library_id'";
  }
  else {
    $sql_select = "SELECT library_id,uniquename,name FROM library WHERE %s='$library_id'";
  }


  if (!is_numeric($library_id)) {
    $library_id = "'". $library_id ."'";
    if (empty($limit) || $limit === 'uniquename') {
      $dbdata = db_fetch_array(db_query($sql_select, 'uniquename'));
    }
    if (empty($dbdata)) {
      if (empty($limit) || $limit === 'name') {
        $dbdata = db_fetch_array(db_query($sql_select, 'name'));
      }
    }
  }


  else {
    //library id or dbest
    if (empty($limit) || $limit === 'library_id') {
      $dbdata = db_fetch_array(db_query($sql_select, 'library_id'));
    }
    if (empty($dbdata)) {
      if (empty($limit) || $limit === 'dbEST') {
        if ($is_chado === FALSE) {
          $sql_select = "SELECT lib.library_id,lib.uniquename,lib.name FROM {gmod_dbsf_library} as lib join " . " {gmod_dbsf_library_dbxref} as ld on lib.library_id=ld.library_id join {gmod_dbsf_dbxref} as d on d.dbxref_id=ld.dbxref_id join ". " {gmod_dbsf_db} on d.db_id=db.db_id WHERE d.accession='$library_id' AND db.name='dbEST'";
        }
        else {
          $sql_select = "SELECT lib.library_id,lib.uniquename,lib.name FROM library as lib join " . " library_dbxref as ld on lib.library_id=ld.library_id join dbxref as d on d.dbxref_id=ld.dbxref_id join ". " db on d.db_id=db.db_id WHERE d.accession='$library_id' AND db.name='dbEST'";
        }
        $dbdata = db_fetch_array(db_query($sql_select));
      }
    }
  }


  if (empty($dbdata)) {
    return FALSE;
  }
  if ($is_chado == TRUE && $full_access !== TRUE) {
    $access = gmod_dbsf_chadoapi_check_restriction('select', 'library', $dbdata['library_id']);
  }
  if ($is_chado === FALSE || $access === TRUE || $full_access === TRUE) {
    return array('uniquename' => $dbdata['uniquename'], 'name' => $dbdata['name'], 'library_id' => $dbdata['library_id'],'id'=>$dbdata['library_id']);
  }
  return FALSE;
}

/**
 * Create a GFF3 file for a feature
 *
 * @param $feature_id
 * the feature ID or uniquename
 * @param $outfile
 * the output filename
 *
 * @return boolean
 * True on success
 */
function gmod_dbsf_feature2gff3($feature_id, $outfile) {
  // this function is slower than the ones using materialized views
  // but  it does not depend on them.
  if (empty($feature_id) || empty($outfile)) {
    return;
  }
  $feature_uname = '';
  if (!is_numeric($feature_id)) {
    $feature_uname = $feature_id;
    $is_chado      = gmod_dbsf_is_chado();
    $sql           = '';
    if ($is_chado === FALSE) {
      $sql = "SELECT feature_id FROM {gmod_dbsf_feature} as feature WHERE uniquename='%s'";
    }
    else {
      $sql = "SELECT feature_id FROM feature WHERE uniquename='%s'";
    }
    $res = db_fetch_array(db_query($sql, $feature_uname));
    $feature_id = $res['feature_id'];
    if (empty($feature_id)) {
      return;
    }
  }
  else {
    if ($is_chado === FALSE) {
      $sql = "SELECT uniquename FROM {gmod_dbsf_feature} as feature WHERE feature_id=%d";
    }
    else {
      $sql = "SELECT uniquename FROM feature WHERE feature_id=%d";
    }
    $res = db_fetch_array(db_query($sql, $feature_id));
    $feature_uname = $res['uniquename'];
  }
  $gff_outdata    = '';
  $fsa_outdata    = '';
  $sql_all_select = '';
  if ($is_chado === FALSE) {
    $sql_all_select = "SELECT sf.name AS ref, dbx.accession AS source, cv.name AS type, fl.fmin + 1 AS fstart, fl.fmax AS fend, " . " fl.strand, fl.phase, f.name, f.uniquename as uname, f.residues as seq, org.abbreviation as abbr " . " FROM {gmod_dbsf_feature} f " . " LEFT JOIN {gmod_dbsf_featureloc} fl ON f.feature_id = fl.feature_id " . " LEFT JOIN {gmod_dbsf_feature} sf ON fl.srcfeature_id = sf.feature_id " . " LEFT JOIN {gmod_dbsf_dbxref} dbx ON dbx.dbxref_id = f.dbxref_id " . " LEFT JOIN {gmod_dbsf_cvterm} cv ON f.type_id = cv.cvterm_id " . " LEFT JOIN {gmod_dbsf_organism} org ON f.organism_id=org.organism_id " . " WHERE sf.name='%s'";
  }
  else {
    $sql_all_select = "SELECT sf.name AS ref, dbx.accession AS source, cv.name AS type, fl.fmin + 1 AS fstart, fl.fmax AS fend, " . " fl.strand, fl.phase, f.name, f.uniquename as uname, f.residues as seq, org.abbreviation as abbr " . " FROM feature f " . " LEFT JOIN featureloc fl ON f.feature_id = fl.feature_id " . " LEFT JOIN feature sf ON fl.srcfeature_id = sf.feature_id " . " LEFT JOIN dbxref dbx ON dbx.dbxref_id = f.dbxref_id " . " LEFT JOIN cvterm cv ON f.type_id = cv.cvterm_id " . " LEFT JOIN organism org ON f.organism_id=org.organism_id " . " WHERE sf.name='%s'";
  }


  //create ref seq and any placeholders
  $res = db_query($sql_all_select, $feature_name);
  if (!empty($res)) {
    if (!file_exists($outfile)) {
      $gff_outdata .= "##gff-version 3\n";
    }
    if (!file_exists($outfile .'.fsa')) {
      $fsa_outdata .= "##gff-version 3\n##FASTA";
    }
  }

  while ($row = db_fetch_array($res)) {
    $ref = !empty($row['ref']) ? $row['ref'] : $feature_name;
    $source = !empty($row['source']) ? $row['source'] : 'source';
    // never empty
    $type  = $row['type'];
    $seq   = $row['seq'];
    $start = !empty($row['fstart']) ? $row['fstart'] : 1;
    $end   = !empty($row['fend']) ? $row['fend'] : '';
    if (empty($end)) {
      //self-ref
      $end = strlen($seq);
    }
    $score  = '.';
    $strand = !empty($row['strand']) ? $row['strand'] : '.';
    $phase  = !empty($row['phase']) ? $row['phase'] : '.';

    // never empty
    $uname    = $row['uname'];
    $name     = !empty($row['name']) ? $row['name'] : $uname;
    $org_abbr = !empty($row['abbr']) ? $row['abbr'] : 'unknown';
    $gff_outdata .= "$ref\t$source\t$type\t$start\t$end\t$score\t$strand\t$phase\tID=$uname;Name=$name;organism=$org_abbr;score=$score";
    if (!empty($seq)) {
      $seq = wordwrap($seq, 80, "\n", TRUE);
      $fsa_outdata .= ">$name\n$seq\n";
    }
  }
  unset($res);

  // the data will be appended to the GFF and FASTA outfiles.
  ini_set('auto_detect_line_endings', TRUE);
  $gff_res = file_put_contents($outfile, $gff_outdata . PHP_EOL, FILE_APPEND);
  $fsa_res = file_put_contents($outfile .'.fsa', $fsa_outhandle . PHP_EOL, FILE_APPEND);
  if (empty($gff_res)) {
    drupal_set_message(t('Could not create %outfile.', array('%outfile' => $outfile)), 'error');
    return FALSE;
  }
  if (empty($fsa_res)) {
    drupal_set_message(t('Could not create %outfile' . '.fsa', array('%outfile' => $outfile)), 'error');
    return FALSE;
  }
  return TRUE;
}

/**
 * Count results in a GFF file
 *
 * @param $infile
 *
 * @return
 */
function gmod_dbsf_count_gfffile($infile) {
  if (empty($infile)) {
    return;
  }
  $return_array = array();
  if ($inhandle = fopen($infile, 'rb')) {
    while (!feof($inhandle)) {
      $line = trim(fgets($inhandle));
      if (!empty($line)) {
        if (strpos($line, '#') === 0) {
          continue;
        }
        $data = explode("\t", $line);
        $return_array[$data[0]][$data[1]][$data[2]]++;
      }
    }
    fclose($inhandle);
  }
  return $return_array;
}

/**
 * Parse a GFF3 file
 *
 * @param $infile
 * the full path to the GFF file
 *
 * @return associative array
 * Each element in the array is an array with the keys 'source', 'type', 'start', 'end', 'score', 'strand',
 * 'phase', and 'attributes'. The latter is an associative array with keys being the tag names returned
 * in a fashion similar to BioPerl's FeatureIO get_tag_values
 */
function gmod_dbsf_parse_gfffile($infile) {
  if (empty($infile)) {
    return;
  }
  $return_array = array();
  if ($inhandle = fopen($infile, 'rb')) {
    while (!feof($inhandle)) {
      $line = trim(fgets($inhandle));
      if (!empty($line)) {
        if (strpos($line, '#') === 0) {
          continue;
        }
        $data       = explode("\t", $line);
        $data[0]    = preg_replace('/^gi\|\d+\|/', '', $data[0]);
        $attributes = array();
        $array      = explode(';', $data[8]);
        foreach ($array as $str) {
          $att_array = explode('=', $str);
          if (!empty($att_array[1])) {
            if ($att_array[0] == 'ID' || $att_array[0] == 'Name') {
              $att_array[1] = preg_replace('/^gi\|\d+\|/', '', $att_array[1]);
            }
            $attributes[$att_array[0]][] = urldecode($att_array[1]);
          }
        }
        $return_array[$data[0]][] = array(
          'source' => $data[1],
          'type' => $data[2],
          'start' => $data[3],
          'end' => $data[4],
          'score' => $data[5],
          'strand' => $data[6],
          'phase' => $data[7],
          'attributes' => $attributes,
        );
      }
    }
    fclose($inhandle);
  }
  return $return_array;
}

/**
 * Get the roles of any user
 *
 * This is a Drupal-specific function
 *
 * @param $name_as_key
 * if TRUE then the name of the user will be the key of the array, ID the value
 * if BOTH then then both key and value will be the username
 * else the userid is the key of the array with the username as the value
 *
 * @return associative array
 */
function gmod_dbsf_get_users_roles($name_as_key = NULL) {
  $sql_roles     = 'SELECT rid as id,name FROM {role}';
  $sql_users     = 'SELECT uid as id,name FROM {users}';
  $results_array = array();
  $res           = db_query($sql_roles);
  while ($row = db_fetch_array($res)) {
    if (empty($row['name'])) {
      continue;
    }
    if (empty($name_as_key)) {
      $results_array['roles'][$row['id']] = $row['name'];
    }
    elseif ($name_as_key == 'BOTH') {
      $results_array['roles'][$row['name']] = $row['name'];
    }
    else {
      $results_array['roles'][$row['name']] = $row['id'];
    }
  }
  $res = db_query($sql_users);
  while ($row = db_fetch_array($res)) {
    if (empty($row['name'])) {
      continue;
    }
    if (empty($name_as_key)) {
      $results_array['users'][$row['id']] = $row['name'];
    }
    elseif ($name_as_key == 'BOTH') {
      $results_array['users'][$row['name']] = $row['name'];
    }
    else {
      $results_array['users'][$row['name']] = $row['id'];
    }
  }
  return $results_array;
}

/**
 * Add a new CV, if it does not exist, return ID
 *
 * Works with Drupal and Chado
 * Used for making a new CV without any associated cvterms or just getting
 * the CV ID of an existing one
 *
 * @param $cvname
 * the name to give to your CV
 * @param $definition
 * optionally, a definition to store for the CV
 *
 * @return integer
 * the internal ID of the CV or FALSE if it failed.
 */
function gmod_dbsf_add_cv_only($cvname, $definition = NULL) {
  if (empty($cvname)) {
    return;
  }

  $is_chado = gmod_dbsf_is_chado();
  $sql_check = '';
  if ($is_chado === FALSE) {
    $sql_check = "SELECT cv_id as id,definition as def FROM {gmod_dbsf_cv} as cv WHERE name='%s'";
  }
  else {
    $sql_check = "SELECT cv_id as id,definition as def FROM cv WHERE name='%s'";
  }
  if (!empty($definition)) {
    $sql_insert = '';
    $sql_update = '';
    if ($is_chado === FALSE) {
      $sql_insert = "INSERT INTO {gmod_dbsf_cv} (name,definition) VALUES ('%s','%s')";
      $sql_update = "UPDATE {gmod_dbsf_cv} set definition='%s' WHERE name='%s'";
    }
    else {
      $sql_insert = "INSERT INTO cv (name,definition) VALUES ('%s','%s')";
      $sql_update = "UPDATE cv set definition='%s' WHERE name='%s'";
    }
    $check = db_fetch_array(db_query($sql_check, $cvname));
    if (empty($check['id'])) {
      db_query($sql_insert, $cvname, $definition);
      $check = db_fetch_array(db_query($sql_check, $cvname));
      if (empty($check['id'])) {
        drupal_set_message(t('4: Failed to add cv %cvname. Perhaps a permissions error?', array('%cvname' => $cvname)), 'error');
      }
      else {
        return $check['id'];
      }
    }
    elseif (empty($check['def'])) {
      db_query($sql_update, $definition, $cvname);
      return $check['id'];
    }
  }
  else {
    $sql_insert = '';
    if ($is_chado === FALSE) {
      $sql_insert = "INSERT INTO {gmod_dbsf_cv} (name) VALUES ('%s')";
    }
    else {
      $sql_insert = "INSERT INTO cv (name) VALUES ('%s')";
    }
    $check = db_fetch_array(db_query($sql_check, $cvname));
    if (empty($check['id'])) {
      db_query($sql_insert, $cvname);
    }
    $check = db_fetch_array(db_query($sql_check, $cvname));
    if (empty($check['id'])) {
      drupal_set_message(t('5: Failed to add cv %cvname. Perhaps a permissions error?', array('%cvname' => $cvname)), 'error');
    }
    else {
      return $check['id'];
    }
  }
}

/**
 * Get databases registered in settings.ini according to their type
 *
 * @todo currently, we are following the est2assembly nomenclature, however in the
 * future we should make a connection to each database explictly and check for a
 * specific table (it will be much slower but can be controlled by a switch)
 *
 * @return associative array with 'SeqFeature', 'Chado' and 'Drupal' for the
 * databases which follow the pattern [a-z]{2}_\d+ , /chado/i or everything else
 * respectively. Note that the seqfeature database
 */
function gmod_dbsf_get_defined_dbs() {
  $return_array = array('Drupal' => array('default'));
  global $db_url;
  if (is_array($db_url)) {
    foreach ($db_url as $name => $url) {
      if (stripos($name, 'chado') !== FALSE) {
        $return_array['Chado'][] = $name;
      }
      elseif (preg_match('/^[a-z]{2}_\d+/', $name)) {
        $return_array['SeqFeature'][] = $name;
      }
      else {
        $return_array['Drupal'][] = $name;
      }
    }
  }
  return $return_array;
}

/**
 * Link a Drupal role with a resource
 *
 * @param $resource
 *   The ID or uniquename of the resource to link
 * @param $role
 *   The ID or name of the Drupal role to link
 * @param $switch
 *  Boolean of whether to delete instead of linking an association.
 *  TRUE deletes. Also, TOGGLE links if unlinked and deletes if linked.
 *
 * @return
 *   FALSE on failure, GRANTED/REVOKED on success
 */
function gmod_dbsf_link_unlink_resource_role($resource, $role, $switch = FALSE) {
  if (empty($resource) || empty($role)) {
    return FALSE;
  }
  $role       = check_plain($role);
  $resource   = check_plain($resource);
  $sql_check  = '';
  $sql_insert = '';
  $sql_delete = '';
  if (is_numeric($role)) {
    $sql_check  = "SELECT resource_role_id FROM {gmod_dbsf_resource_role} WHERE role_id=%d AND resource_id=";
    $sql_insert = "INSERT INTO {gmod_dbsf_resource_role} (role_id,resource_id) VALUES (%d,";
    $sql_delete = "DELETE FROM {gmod_dbsf_resource_role} WHERE role_id=%d AND resource_id=";
  }
  else {
    $sql_check  = 'SELECT resource_role_id FROM {gmod_dbsf_resource_role} WHERE role_id=' . "(SELECT rid FROM {role} WHERE name='%s') AND resource_id=";
    $sql_insert = 'INSERT INTO {gmod_dbsf_resource_role} (role_id,resource_id) VALUES (' . "(SELECT rid FROM {role} WHERE name='%s'),";
    $sql_delete = 'DELETE FROM {gmod_dbsf_resource_role} WHERE role_id=' . "(SELECT rid FROM {role} WHERE name='%s') AND resource_id=";
  }
  if (is_numeric($resource)) {
    $sql_check .= "%d";
    $sql_insert .= "%d)";
    $sql_delete .= "%d";
  }
  else {
    $sql_check .= "(SELECT resource_id FROM {gmod_dbsf_resource} WHERE uniquename='%s')";
    $sql_insert .= "(SELECT resource_id FROM {gmod_dbsf_resource} WHERE uniquename='%s'))";
    $sql_delete .= "(SELECT resource_id FROM {gmod_dbsf_resource} WHERE uniquename='%s')";
  }

  $res = db_fetch_array(db_query($sql_check, $role, $resource));
  switch ($switch) {
    case FALSE:
      if (empty($res)) {
        db_query($sql_insert, array($role, $resource));
        return 'GRANTED';
      }
      else {
        return 'GRANTED';
      }
      break;

    case 'GRANT':
      if (empty($res)) {
        db_query($sql_insert, array($role, $resource));
        return 'GRANTED';
      }
      else {
        return 'GRANTED';
      }
      break;

    case 'TOGGLE':
      if (empty($res)) {
        db_query($sql_insert, array($role, $resource));
        return 'GRANTED';
      }
      else {
        db_query($sql_delete, array($role, $resource));
        $res = db_fetch_array(db_query($sql_check, array($role, $resource)));
        if (empty($res)) {
          return 'REVOKED';
        }
        else {
          //dvm("Failed to delete previous link for role $role and resource $resource.");
          return FALSE;
        }
      }
      break;

    case 'REVOKE':
      if (empty($res)) {
        return 'REVOKED';
      }
      else {
        db_query($sql_delete, array($role, $resource));
        $res = db_fetch_array(db_query($sql_check, array($role, $resource)));
        if (empty($res)) {
          return 'REVOKED';
        }
        else {
          //dvm("Failed to delete previous link for role $role and resource $resource.");
          return FALSE;
        }
      }
      break;

    case TRUE:
      if (empty($res)) {
        return 'REVOKED';
      }
      else {
        db_query($sql_delete, array($role, $resource));
        $res = db_fetch_array(db_query($sql_check, array($role, $resource)));
        if (empty($res)) {
          return 'REVOKED';
        }
        else {
          //dvm("Failed to delete previous link for role $role and resource $resource.");
          return FALSE;
        }
      }
      break;
  }
}

/**
 * Link a software with a specific resource
 *
 * @param $software
 *   The ID or uniquename of the software to link
 * @param $resource
 *   The id or name of the resource to link
 * @param $switch
 *   Boolean of whether to delete instead of linking an association.
 *  TRUE deletes. Also, TOGGLE links if unlinked and deletes if linked.
 *
 * @return
 *   FALSE on failure, GRANTED/REVOKED on success
 */
function gmod_dbsf_link_unlink_software_resource($software, $resource, $switch = FALSE) {
  if (empty($resource) || empty($software)) {
    return FALSE;
  }
  $software   = check_plain($software);
  $resource   = check_plain($resource);
  $sql_check  = '';
  $sql_insert = '';
  $sql_delete = '';
  if (is_numeric($software)) {
    $sql_check  = "SELECT software_resource_id FROM {gmod_dbsf_software_resource} WHERE software_id=%d AND resource_id=";
    $sql_insert = "INSERT INTO {gmod_dbsf_software_resource} (software_id,resource_id) VALUES (%d,";
    $sql_delete = "DELETE FROM {gmod_dbsf_software_resource} WHERE software_id=%d AND resource_id=";
  }
  else {
    $sql_check  = 'SELECT software_resource_id FROM {gmod_dbsf_software_resource} WHERE software_id=' . "(SELECT software_id FROM {gmod_dbsf_software} WHERE uniquename='%s') AND resource_id=";
    $sql_insert = 'INSERT INTO {gmod_dbsf_software_resource} (software_id,resource_id) VALUES (' . "(SELECT software_id FROM {gmod_dbsf_software} WHERE uniquename='%s'),";
    $sql_delete = 'DELETE FROM {gmod_dbsf_software_resource} WHERE software_id=' . "(SELECT software_id FROM {gmod_dbsf_software} WHERE uniquename='%s') AND resource_id=";
  }
  if (is_numeric($resource)) {
    $sql_check .= '%d';
    $sql_insert .= '%d' . ')';
    $sql_delete .= '%d';
  }
  else {
    $sql_check .= " (SELECT resource_id FROM {gmod_dbsf_resource} WHERE uniquename='%s')";
    $sql_insert .= "(SELECT resource_id FROM {gmod_dbsf_resource} WHERE uniquename='%s')" . ')';
    $sql_delete .= "(SELECT resource_id FROM {gmod_dbsf_resource} WHERE uniquename='%s')";
  }


  $res = db_fetch_array(db_query($sql_check, array($software, $resource)));
  switch ($switch) {
    case FALSE:
      if (empty($res)) {
        db_query($sql_insert, array($software, $resource));
        return 'GRANTED';
      }
      else {
        return 'GRANTED';
      }
      break;

    case 'GRANT':
      if (empty($res)) {
        db_query($sql_insert, array($software, $resource));
        return 'GRANTED';
      }
      else {
        return 'GRANTED';
      }
      break;

    case 'TOGGLE':
      if (empty($res)) {
        db_query($sql_insert, array($software, $resource));
        return 'GRANTED';
      }
      else {
        db_query($sql_delete, array($software, $resource));
        $res = db_fetch_array(db_query($sql_check, array($software, $resource)));
        if (empty($res)) {
          return 'REVOKED';
        }
      }
      break;

    case 'REVOKE':
      if (empty($res)) {
        return 'REVOKED';
      }
      else {
        db_query($sql_delete, array($software, $resource));
        $res = db_fetch_array(db_query($sql_check, array($software, $resource)));
        if (empty($res)) {
          return 'REVOKED';
        }
        else {
          //dvm("Failed to delete previous link for software $software and resource $resource.");
          return FALSE;
        }
      }
      break;

    case TRUE:
      if (empty($res)) {
        return 'REVOKED';
      }
      else {
        db_query($sql_delete, array($software, $resource));
        $res = db_fetch_array(db_query($sql_check, array($software, $resource)));
        if (empty($res)) {
          return 'REVOKED';
        }
        else {
          //dvm("Failed to delete previous link for software $software and resource $resource.");
          return FALSE;
        }
      }
      break;
  }
}

/**
 * Get the properties FROM the softwareprop table
 *
 * @param $limit
 *   Optionally add a limit. It can be a string to be added after WHERE
 *   or an array WHERE they keys are the column names
 * @param $name_as_key
 *   If TRUE, set the return array to use the software uniquename as the key
 *
 * @return
 *   A 3D associative array. First key is ID or name (controlled by
 *   $name_as_key); second key is the type_name and third is the rank
 *   (an integer). The value of the property is the value of the array.
 */
function gmod_dbsf_get_softwareprop($limit = NULL, $name_as_key = FALSE) {
  $return_array = array();
  $sql_select = 'SELECT s.uniquename as software_name,s.software_id as software_id,' . ' cvterm.name as type_name,sp.value,sp.rank ' . ' FROM {gmod_dbsf_softwareprop} as sp ' . ' JOIN {gmod_dbsf_software} as s ON s.software_id=sp.software_id ' . ' JOIN {gmod_dbsf_cvterm} as cvterm on sp.type_id=cvterm.cvterm_id ' . ' WHERE TRUE';

  if (!empty($limit)) {
    if (is_array($limit)) {
      foreach ($limit as $column => $data) {
        $sql_select .= " AND $column='$data'";
      }
    }
    else {
      $sql_select .= " AND $limit";
    }
  }
  $res = db_query($sql_select);
  while ($row = db_fetch_array($res)) {
    if (!empty($name_as_key)) {
      $return_array[$row['software_name']][$row['type_name']][$row['rank']] = $row['value'];
    }
    else {
      $return_array[$row['software_id']][$row['type_name']][$row['rank']] = $row['value'];
    }
  }
  if (!empty($return_array)) {
    return $return_array;
  }
  else {
    return FALSE;
  }
}

/**
 * Get all resources linked for a specific software
 *
 * @param $limit
 *  Aptionally an array or string to add a constraint.
 *  NB: The software table is aliased as s; resource as r; software_resource
 *  as sr and cvterm (linked with resource) as rcvterm
 * @param $name_as_key
 *   A boolean, if TRUE then return array uses names instead of IDs
 *
 * @return
 *   An associative array WHERE first keys is the software id/name, second key
 *   is the resource id/name. The value is the name of the resource type.
 */
function gmod_dbsf_get_software_resources($limit = NULL, $name_as_key = FALSE) {

  $return_array = array();
  $sql_select = 'SELECT sr.software_id as software_id,sr.resource_id, ' . ' s.uniquename as software_name,r.uniquename as resource_name,r.organism_id, ' . ' rcvterm.name as rtype_name,r.description FROM {gmod_dbsf_software_resource} as sr ' . ' JOIN {gmod_dbsf_resource} as r on r.resource_id=sr.resource_id ' . ' JOIN {gmod_dbsf_software} as s on sr.software_id=s.software_id ' . ' JOIN {gmod_dbsf_cvterm} as rcvterm on r.type_id=rcvterm.cvterm_id ' . ' WHERE TRUE';

  $org_general_sql = "SELECT organism_id FROM {gmod_dbsf_organism} as organism WHERE genus='general'";
  $org_general_res = db_fetch_array(db_query($org_general_sql));
  $null_org_id     = !empty($org_general_res['organism_id']) ? $org_general_res['organism_id'] : 0;
  if (!empty($limit)) {
    if (is_array($limit)) {
      foreach ($limit as $column => $data) {
        $sql_select .= " AND $column='$data'";
      }
    }
    else {
      $sql_select .= " AND $limit";
    }
  }

  $res = db_query($sql_select);
  while ($row = db_fetch_array($res)) {
    $org_id = $null_org_id !== $row['organism_id'] ? $row['organism_id'] : 0;
    if (!empty($name_as_key) && $name_as_key === 'RESOURCE') {
      $return_array[$row['resource_name']][$row['software_name']] = array(
        'type_name' => $row['rtype_name'],
        'uniquename' => $row['software_name'],
        'id' => $row['software_id'],
        'description' => $row['description'],
        'organism_id' => $org_id,
      );
    }
    elseif (!empty($name_as_key)) {
      $return_array[$row['software_name']][$row['resource_name']] = array(
        'type_name' => $row['rtype_name'],
        'uniquename' => $row['resource_name'],
        'id' => $row['resource_id'],
        'description' => $row['description'],
        'organism_id' => $org_id,
      );
    }
    else {
      $return_array[$row['software_id']][$row['resource_id']] = array(
        'type_name' => $row['rtype_name'],
        'uniquename' => $row['resource_name'],
        'id' => $row['resource_id'],
        'description' => $row['description'],
        'organism_id' => $org_id,
      );
    }
  }
  if (!empty($return_array)) {
    return $return_array;
  }
  else {
    return FALSE;
  }
}



/**
 * Manipulate the Drupal variable table
 *
 * You can add, get, delete and update variables with one go. It checks
 * if the active db is chado and then it reconnects to chado
 * @see variable_del
 * @see variable_get
 * @see variable_set
 *
 * @param $name
 * The name field
 * @param $value
 * The value field. If empty, it performs a GET, if it is set as DELETE then
 * it deletes the entry
 * @param $db_reconnect
 * If provided, this is the alias of the db to reconnect back to. defaults to
 * chado
 *
 * @return mixed
 * If getting, the value of the variable or FALSE on failure
 * If adding/updating/deleting TRUE on success, FALSE on failure
 */
function gmod_dbsf_get_add_var($name = NULL, $value = NULL, $db_reconnect = TRUE) {
  $name = check_plain($name);
  if (is_string($value)){
    $value = check_plain($value);
  }elseif (is_array($value)){
    $new_value=array();
    foreach ($value as $a=>$b){
      $a=check_plain($a);
      $b=check_plain($b);
      $new_value[$a]=$b;
    }
    $value=$new_value;
    unset($new_value);
  }
  if (empty($name)) {
    return;
  }
  if (!empty($db_reconnect)){
    if  (!is_string($db_reconnect)){
      global $active_db;
      $db_reconnect= pg_dbname($active_db);
    }
  }
  $is_chado = gmod_dbsf_is_chado();
  $check_sql = "SELECT name FROM {variable} WHERE name='%s'";

  // remember what our connection was
  if ($is_chado === TRUE) {
    gmod_dbsf_db_execute();
  }
  if (empty($value)) {
    //GET
    $data = variable_get($name, $value);
    if (!empty($data)) {
      if ($is_chado === TRUE) {
        gmod_dbsf_db_execute($db_reconnect);
      }
      return $data;
    }
    else {
      if ($is_chado === TRUE) {
        gmod_dbsf_db_execute($db_reconnect);
      }
      return FALSE;
    }
  }
  elseif ($value === 'DELETE') {
    //DELETE
    variable_del($name);
    $data = db_fetch_array(db_query($check_sql, $name));
    if (!empty($data)) {
      if ($is_chado == TRUE) {
        gmod_dbsf_db_execute($db_reconnect);
      }
      return FALSE;
    }
    else {
      if ($is_chado == TRUE) {
        gmod_dbsf_db_execute($db_reconnect);
      }
      return TRUE;
    }
  }
  else {
    //ADD UPDATE
    variable_set($name, $value);
    $data = db_fetch_array(db_query($check_sql, $name));
    if (!empty($data)) {
      if ($is_chado == TRUE) {
        gmod_dbsf_db_execute($db_reconnect);
      }
      return TRUE;
    }
    else {
      if ($is_chado == TRUE) {
        gmod_dbsf_db_execute($db_reconnect);
      }
      return FALSE;
    }
  }
}

/**
 * Get an organism ID after storing the complete taxonomy using NCBI
 *
 * @param $ncbi_taxid
 * the NCBI Taxonomy ID to retrieve
 *
 * @return associative array of results
 * - 'organism_id' Organism ID
 * - 'common_name' Common name
 * - 'species' Species
 * - 'genus' Genus
 * - 'class' Class
 * - 'order' Order
 * - 'family' Family
 * - 'ncbi_taxid' NCBI taxonomy ID
 */
function gmod_dbsf_get_taxonomy_from_ncbi($ncbi_taxid) {
  if (empty($ncbi_taxid)) {
    return;
  }
  $tax_db = gmod_dbsf_get_add_var('gmod_dbsf_taxonomy_directory');
  $exec = './'. drupal_get_path('module', 'gmod_dbsf') .'/scripts/get_species_ncbi.pl';
  if (!file_exists($exec)) {
    drupal_set_message(t('Cannot find the get_species_ncbi.pl program.'), 'error');
    return FALSE;
  }
  elseif (!is_executable($exec)) {
    drupal_set_message(t('Cannot execute the %f program.', array('%f' => $exec)), 'error');
    return FALSE;
  }
  $args = " -n $ncbi_taxid";
  if (!empty($tax_db) && file_exists($tax_db .'/names.dmp')) {
    $args .= " -flat $tax_db";
  }
  $output   = array();
  $taxonomy = array();
  $result   = exec($exec . $args .' 2>&1', $output, $return_var);
  if (empty($result)) {
    drupal_set_message(t('Failed to find any entry with ID %ncbi_taxid.', array('%ncbi_taxid' => $ncbi_taxid)), 'error');
    return FALSE;
  }
  if (preg_match('/^class/', $result)) {
    $result = trim($result);
    // TODO i'm sure there is a php function for this.
    $ln_data = explode(';', $result);
    foreach ($ln_data as $data) {
      $values = explode(':', $data);
      $taxonomy[$values[0]] = $values[1];
    }
  }
  else {
    drupal_set_message(t('Failed to find any entry with ID %ncbi_taxid.', array('%ncbi_taxid' => $ncbi_taxid)), 'error');
    return FALSE;
  }
  if (empty($taxonomy['species'])) {
    drupal_set_message(t('Failed to find any entry with ID %ncbi_taxid.', array('%ncbi_taxid' => $ncbi_taxid)), 'error');
    return FALSE;
  }

  $org_id = gmod_dbsf_get_add_organism(array(
      'pgtype' => 'drupal',
      'common_name' => $taxonomy['common'],
      'species' => $taxonomy['species'],
      'genus' => $taxonomy['genus'],
      'class' => $taxonomy['class'],
      'order' => $taxonomy['order'],
      'family' => $taxonomy['family'],
      'ncbi_taxid' => $taxonomy['ncbi'],
  )
  );
  return array('organism_id' => $org_id, 'common_name' => $taxonomy['common'], 'species' => $taxonomy['species'], 'genus' => $taxonomy['genus'], 'class' => $taxonomy['class'],
    'order' => $taxonomy['order'], 'family' => $taxonomy['family'], 'ncbi_taxid' => $taxonomy['ncbi'],
  );
}

function gmod_dbsf_drupal_root(){
  $path = getcwd().'/';
  // if we are at a different directory rather than Drupal root, then use the realpath way (breaks symlinks and less fast
  if (!is_file($path.'install.php')){
    return realpath('.'.base_path()).'/';
  }
  return $path;
}

/*
 * Get median from an array of numbers. Inefficiently.
 */
function gmod_dbsf_median($array,$size=NULL,$sorted=FALSE){
  if (empty($array)){return;}
  if (empty($sorted)){
    sort($array);
  }
    $median = 0;
  if (empty($size)){
    $size = count($array);
  }
  $h = intval($size / 2);
  if($size % 2 == 0) {
    $median = ($array[$h] + $array[$h-1]) / 2;
  } else {
    $median = $array[$h];
  }
  return sprintf("%.1f",$median);
}
